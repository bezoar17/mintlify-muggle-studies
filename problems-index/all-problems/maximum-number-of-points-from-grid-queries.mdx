---
title: '❗️ Maximum Number of Points From Grid Queries'
description: '[leetcode link](https://leetcode.com/problems/maximum-number-of-points-from-grid-queries/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given an <code>m x n</code> integer matrix <code>grid</code> and an array <code>queries</code> of size <code>k</code>.</p>  <p>Find an array <code>answer</code> of size <code>k</code> such that for each integer <code>queries[i]</code> you start in the <strong>top left</strong> cell of the matrix and repeat the following process:</p>  <ul>  <li>If <code>queries[i]</code> is <strong>strictly</strong> greater than the value of the current cell that you are in, then you get one point if it is your first time visiting this cell, and you can move to any <strong>adjacent</strong> cell in all <code>4</code> directions: up, down, left, and right.</li>  <li>Otherwise, you do not get any points, and you end this process.</li> </ul>  <p>After the process, <code>answer[i]</code> is the <strong>maximum</strong> number of points you can get. <strong>Note</strong> that for each query you are allowed to visit the same cell <strong>multiple</strong> times.</p>  <p>Return <em>the resulting array</em> <code>answer</code>.</p>   <p><strong class="example">Example 1:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2025/03/15/image1.png" style="width: 571px; height: 152px;" />  <strong>Input:</strong> grid = [[1,2,3],[2,5,7],[3,5,1]], queries = [5,6,2] <br/> <strong>Output:</strong> [5,8,1] <br/> <strong>Explanation:</strong> The diagrams above show which cells we visit to get points for each query.  <p><strong class="example">Example 2:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2022/10/20/yetgriddrawio-2.png" />  <strong>Input:</strong> grid = [[5,2,1],[1,1,2]], queries = [3] <br/> <strong>Output:</strong> [0] <br/> <strong>Explanation:</strong> We can not get any points because the value of the top left cell is already greater than or equal to 3.    <p><strong>Constraints:</strong></p>  <ul>  <li><code>m == grid.length</code></li>  <li><code>n == grid[i].length</code></li>  <li><code>2 &lt;= m, n &lt;= 1000</code></li>  <li><code>4 &lt;= m * n &lt;= 10<sup>5</sup></code></li>  <li><code>k == queries.length</code></li>  <li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>  <li><code>1 &lt;= grid[i][j], queries[i] &lt;= 10<sup>6</sup></code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Order queries in ascending order. Start bfs from top-left, picking lower neighbors first with a pq.
And do bfs in valid range till the current query allows. And update the answer. 
    </Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Maximum Number of Points From Grid Queries" lines
# @param {Integer[][]} grid
# @param {Integer[]} queries
# @return {Integer[]}
def max_points(grid, queries)
  n, m = grid.size, grid[0].size
  directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]
  visited = Array.new(n) { Array.new(m, false) }
  answer = Array.new(queries.size, 0)
  total_points = 0

  sorted_queries = queries.each_with_index.sort
  min_priority_queue = PriorityQueue.new
  min_priority_queue.push([0, 0], grid[0][0])
  visited[0][0] = true

  sorted_queries.each do |query, index|
    while !min_priority_queue.empty? && min_priority_queue.peek[1] < query
      i, j = min_priority_queue.pop[0]
      total_points += 1

      directions.each do |dx, dy|
        new_x, new_y = i + dx, j + dy

        if new_x >= 0 && new_x < n && new_y >= 0 && new_y < m && !visited[new_x][new_y]
          visited[new_x][new_y] = true
          min_priority_queue.push([new_x, new_y], grid[new_x][new_y])
        end
      end
    end
    answer[index] = total_points
  end

  answer
end

class PriorityQueue
  def initialize
    @heap = []
  end

  def push(item, priority)
    @heap << [item, priority]
    bubble_up_iterative(@heap.size - 1)
    self
  end

  def pop
    return if @heap.empty?

    swap(0, @heap.size - 1)
    min = @heap.pop
    bubble_down_iterative(0) unless @heap.empty?
    min
  end

  def peek
    @heap[0]
  end

  def empty?
    @heap.empty?
  end

  def size
    @heap.size
  end

  private

  def bubble_up_iterative(index)
    while index > 0
      parent_index = (index - 1) / 2
      break if @heap[parent_index][1] <= @heap[index][1]

      swap(index, parent_index)
      index = parent_index
    end
  end

  def bubble_down_iterative(index)
    while true
      min_index = index
      left = 2 * index + 1
      right = left + 1

      min_index = left if left < @heap.size && @heap[left][1] < @heap[min_index][1]
      min_index = right if right < @heap.size && @heap[right][1] < @heap[min_index][1]

      break if min_index == index

      swap(index, min_index)
      index = min_index
    end
  end

  def swap(i, j)
    @heap[i], @heap[j] = @heap[j], @heap[i]
  end
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>