---
title: "❗️ Longest Special Path"
description: '[leetcode link](https://leetcode.com/problems/longest-special-path/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given an undirected tree rooted at node <code>0</code> with <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code>, represented by a 2D array <code>edges</code> of length <code>n - 1</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, length<sub>i</sub>]</code> indicates an edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> with length <code>length<sub>i</sub></code>. You are also given an integer array <code>nums</code>, where <code>nums[i]</code> represents the value at node <code>i</code>.</p>  <p>A <b data-stringify-type="bold">special path</b> is defined as a <b data-stringify-type="bold">downward</b> path from an ancestor node to a descendant node such that all the values of the nodes in that path are <b data-stringify-type="bold">unique</b>.</p>  <p><strong>Note</strong> that a path may start and end at the same node.</p>  <p>Return an array <code data-stringify-type="code">result</code> of size 2, where <code>result[0]</code> is the <b data-stringify-type="bold">length</b> of the <strong>longest</strong> special path, and <code>result[1]</code> is the <b data-stringify-type="bold">minimum</b> number of nodes in all <i data-stringify-type="italic">possible</i> <strong>longest</strong> special paths.</p>   <p><strong class="example">Example 1:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">edges = [[0,1,2],[1,2,3],[1,3,5],[1,4,4],[2,5,6]], nums = [2,1,2,1,3,1]</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">[6,2]</span></p>  <p><br/> <strong>Explanation:</strong></p>  <h4>In the image below, nodes are colored by their corresponding values in <code>nums</code></h4>  <p><img alt="" src="https://assets.leetcode.com/uploads/2024/11/02/tree3.jpeg" style="width: 250px; height: 350px;" /></p>  <p>The longest special paths are <code>2 -&gt; 5</code> and <code>0 -&gt; 1 -&gt; 4</code>, both having a length of 6. The minimum number of nodes across all longest special paths is 2.</p> </div>  <p><strong class="example">Example 2:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">edges = [[1,0,8]], nums = [2,2]</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">[0,1]</span></p>  <p><br/> <strong>Explanation:</strong></p>  <p><img alt="" src="https://assets.leetcode.com/uploads/2024/11/02/tree4.jpeg" style="width: 190px; height: 75px;" /></p>  <p>The longest special paths are <code>0</code> and <code>1</code>, both having a length of 0. The minimum number of nodes across all longest special paths is 1.</p> </div>   <p><strong>Constraints:</strong></p>  <ul>  <li><code>2 &lt;= n &lt;= 5 * 10<sup><span style="font-size: 10.8333px;">4</span></sup></code></li>  <li><code>edges.length == n - 1</code></li>  <li><code>edges[i].length == 3</code></li>  <li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>  <li><code>1 &lt;= length<sub>i</sub> &lt;= 10<sup>3</sup></code></li>  <li><code>nums.length == n</code></li>  <li><code>0 &lt;= nums[i] &lt;= 5 * 10<sup>4</sup></code></li>  <li>The input is generated such that <code>edges</code> represents a valid tree.</li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      DFS with maintaining at which prev_node of current path was the value of current_node seen. For this we need to know the rightmost prev_node value if there are multiple occurences of value in the path. We need the path information and the value last seen at which node info while doing the dfs and calculating current path length. 

If we are at a node x, consider path to node x as a and array of, and node_0, node_a, node_b ... node_x. Path length of a sub-array [i..x] is path_length of x- path length of i. We have to find subarray [i..x] such that there is no repeating element within this. And record path length of this subarray. So while going from left-right in this subarray(which is dfs from root to node), we keep updating the left_idx or start_idx by keeping track of previously seen values and their idx. Now, this path is built during the dfs from root to a node, so we have to keep the dfs_path, along with the idx at which a value was seen.
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Longest Special Path" lines
# @param {Integer[][]} edges
# @param {Integer[]} nums
# @return {Integer[]}
def longest_special_path(edges, nums)
  max_path_length = -1
  min_node_count = Float::INFINITY
  adj_h = Hash.new {|h,k| h[k]=[]}; edges.each {|u,v,l| adj_h[u] << [v,l]; adj_h[v] << [u,l]}

  path_length_to_node = Array.new(nums.size) # only 1 path to each node, with unique path_length to that node
  
  dfs_path = []
  value_last_idx = {} # for a value, idx in dfs_path where this value was seen last
  # both dfs_path and value_last_idx, have to be reverted to their state after the dfs from this node is completed

  record_valid_path_answer=->(start_idx) {
    right_node = dfs_path[-1] # always the latest node in dfs path
    left_node = dfs_path[start_idx] # starting idx considering unique values
    valid_path_length = path_length_to_node[right_node] - path_length_to_node[left_node]
    node_count = dfs_path.size - start_idx

    if valid_path_length > max_path_length
      max_path_length = valid_path_length
      min_node_count = node_count
    elsif valid_path_length==max_path_length && node_count<min_node_count
      min_node_count = node_count
    end
  }
  
  
  dfs=->(node, start_idx, current_length, parent) {
    path_length_to_node[node] = current_length # unique for each node, just record once for each node
    
    dfs_path << node  # record path of dfs
    node_value = nums[node]
    previous_occurence_idx = value_last_idx[node_value] # record the value before we start dfs, will be restored
    
    # update starting idx of valid path for answer calculation and next dfs
    start_idx = [start_idx, previous_occurence_idx+1].max if !previous_occurence_idx.nil?
    # there can be a case where start_idx is already ahead of previous_occurence_idx+1
    # 0, 1, 2, 1, 0
    # when we are at last 0 value, previous_occurence_idx would suggest starting at 1, 
    # but due to the 2 1s in betweeen, start_idx would already be at 2.
    
    # record valid path lengths and update answer before dfs, processing for the current node
    record_valid_path_answer.call(start_idx)
    # update last idx for the current node value to be used by child nodes in dfs
    value_last_idx[node_value] = dfs_path.size-1

    # do dfs for child nodes
    adj_h[node].each { |ch_node, l| dfs.call(ch_node, start_idx, current_length+l, node) unless ch_node == parent}
    
    # revert the states, after dfs from current node completes
    value_last_idx[node_value] = previous_occurence_idx
    dfs_path.pop
  }

  dfs.call(0, 0, 0, -1)
  [max_path_length, min_node_count]
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>