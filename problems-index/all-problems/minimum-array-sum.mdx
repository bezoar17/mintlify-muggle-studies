---
title: 'ðŸ§€ Minimum Array Sum'
description: '[leetcode link](https://leetcode.com/problems/minimum-array-sum/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given an integer array <code>nums</code> and three integers <code>k</code>, <code>op1</code>, and <code>op2</code>.</p>  <p>You can perform the following operations on <code>nums</code>:</p>  <ul>  <li><strong>Operation 1</strong>: Choose an index <code>i</code> and divide <code>nums[i]</code> by 2, <strong>rounding up</strong> to the nearest whole number. You can perform this operation at most <code>op1</code> times, and not more than <strong>once</strong> per index.</li>  <li><strong>Operation 2</strong>: Choose an index <code>i</code> and subtract <code>k</code> from <code>nums[i]</code>, but only if <code>nums[i]</code> is greater than or equal to <code>k</code>. You can perform this operation at most <code>op2</code> times, and not more than <strong>once</strong> per index.</li> </ul>  <p><strong>Note:</strong> Both operations can be applied to the same index, but at most once each.</p>  <p>Return the <strong>minimum</strong> possible <strong>sum</strong> of all elements in <code>nums</code> after performing any number of operations.</p>   <p><strong class="example">Example 1:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">nums = [2,8,3,19,3], k = 3, op1 = 1, op2 = 1</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">23</span></p>  <p><br/> <strong>Explanation:</strong></p>  <ul>  <li>Apply Operation 2 to <code>nums[1] = 8</code>, making <code>nums[1] = 5</code>.</li>  <li>Apply Operation 1 to <code>nums[3] = 19</code>, making <code>nums[3] = 10</code>.</li>  <li>The resulting array becomes <code>[2, 5, 3, 10, 3]</code>, which has the minimum possible sum of 23 after applying the operations.</li> </ul> </div>  <p><strong class="example">Example 2:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">nums = [2,4,3], k = 3, op1 = 2, op2 = 1</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">3</span></p>  <p><br/> <strong>Explanation:</strong></p>  <ul>  <li>Apply Operation 1 to <code>nums[0] = 2</code>, making <code>nums[0] = 1</code>.</li>  <li>Apply Operation 1 to <code>nums[1] = 4</code>, making <code>nums[1] = 2</code>.</li>  <li>Apply Operation 2 to <code>nums[2] = 3</code>, making <code>nums[2] = 0</code>.</li>  <li>The resulting array becomes <code>[1, 2, 0]</code>, which has the minimum possible sum of 3 after applying the operations.</li> </ul> </div>   <p><strong>Constraints:</strong></p>  <ul>  <li><code>1 &lt;= nums.length &lt;= 100</code></li>  <li><code><font face="monospace">0 &lt;= nums[i] &lt;= 10<sup>5</sup></font></code></li>  <li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>  <li><code>0 &lt;= op1, op2 &lt;= nums.length</code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Typical dp state problem. Just simulate as given.
    </Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Minimum Array Sum" lines
# @param {Integer[]} nums
# @param {Integer} k
# @param {Integer} op1
# @param {Integer} op2
# @return {Integer}
class PseudoSumSegTree
  def initialize(arr)
    @n = arr.size # size of the source array
    # query can have r till n, so sum of all elements is at prefix[n]
    @prefix_sum_arr = (1..@n).reduce([0]) {|res, i| res << res.last + arr[i-1]; res } # sum till i-1
  end
  
  # [l,r)
  def query(l,r)
    @prefix_sum_arr[r] - @prefix_sum_arr[l]
  end
end

def min_array_sum(nums, k, op1, op2)
  @n = nums.size; @nums=nums
  @k = k; @op1 = op1; @op2 = op2;
  @seg_tree = PseudoSumSegTree.new(nums)
  @cache = Array.new(@n+1) { Array.new(@n+1) { Array.new(@n+1, Float::INFINITY) } }
  recursive(0, op1, op2)
end

def recursive(idx, remaining_op1, remaining_op2)
  return 0 if idx>@n-1
  return @cache[idx][remaining_op1][remaining_op2]=@seg_tree.query(idx,@n) if remaining_op1 < 1 && remaining_op2 < 1
  return @cache[idx][remaining_op1][remaining_op2] if @cache[idx][remaining_op1][remaining_op2]!=Float::INFINITY
  
  
  val = @nums[idx];
  
  # dont apply
  option1 = val + recursive(idx+1, remaining_op1, remaining_op2)

  # apply op1
  option2 = (remaining_op1<1) ? Float::INFINITY : ( (val/2.0).ceil  + recursive(idx+1, remaining_op1-1, remaining_op2) )

  # apply op2
  option3 = (remaining_op2<1 || val<@k) ? Float::INFINITY : (val-@k + recursive(idx+1, remaining_op1, remaining_op2-1))
  
  # apply both
  option4 = unless (remaining_op1 > 0 && remaining_op2 >0)
    Float::INFINITY
   else
    new_val_1 = (val < @k) ? Float::INFINITY : ((val-@k)/2.0).ceil
    new_val_2 = (val/2.0).ceil - @k
    new_val = [new_val_1, (new_val_2 < 0 ? Float::INFINITY : new_val_2)].min
    new_val + recursive(idx+1, remaining_op1-1, remaining_op2-1)
   end

  @cache[idx][remaining_op1][remaining_op2]=[option1, option2, option3, option4].min
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>