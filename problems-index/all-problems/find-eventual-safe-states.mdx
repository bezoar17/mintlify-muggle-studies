---
title: "ðŸ§€ Find Eventual Safe States"
description: '[leetcode link](https://leetcode.com/problems/find-eventual-safe-states/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>There is a directed graph of <code>n</code> nodes with each node labeled from <code>0</code> to <code>n - 1</code>. The graph is represented by a <strong>0-indexed</strong> 2D integer array <code>graph</code> where <code>graph[i]</code> is an integer array of nodes adjacent to node <code>i</code>, meaning there is an edge from node <code>i</code> to each node in <code>graph[i]</code>.</p>  <p>A node is a <strong>terminal node</strong> if there are no outgoing edges. A node is a <strong>safe node</strong> if every possible path starting from that node leads to a <strong>terminal node</strong> (or another safe node).</p>  <p>Return <em>an array containing all the <strong>safe nodes</strong> of the graph</em>. The answer should be sorted in <strong>ascending</strong> order.</p>   <p><strong class="example">Example 1:</strong></p> <img alt="Illustration of graph" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/17/picture1.png" style="height: 171px; width: 600px;" />  <strong>Input:</strong> graph = [[1,2],[2,3],[5],[0],[5],[],[]] <br/> <strong>Output:</strong> [2,4,5,6] <br/> <strong>Explanation:</strong> The given graph is shown above. Nodes 5 and 6 are terminal nodes as there are no outgoing edges from either of them. Every path starting at nodes 2, 4, 5, and 6 all lead to either node 5 or 6.  <p><strong class="example">Example 2:</strong></p>   <strong>Input:</strong> graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]] <br/> <strong>Output:</strong> [4] <br/> <strong>Explanation:</strong> Only node 4 is a terminal node, and every path starting at node 4 leads to node 4.    <p><strong>Constraints:</strong></p>  <ul>  <li><code>n == graph.length</code></li>  <li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>  <li><code>0 &lt;= graph[i].length &lt;= n</code></li>  <li><code>0 &lt;= graph[i][j] &lt;= n - 1</code></li>  <li><code>graph[i]</code> is sorted in a strictly increasing order.</li>  <li>The graph may contain self-loops.</li>  <li>The number of edges in the graph will be in the range <code>[1, 4 * 10<sup>4</sup>]</code>.</li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Kahn's algorithm to get topological sort of a DAG. Here, if there is no cycle, then all nodes are safe. Otherwise, all nodes part of a DAG are safe, and all nodes in a cycle are unsafe.
The advantage of using Kahn's technique is that it also aids in the discovery of graph cycles. The Kahn's method does not visit any node in a cycle.

graph is already adjacency list
all terminal nodes are safe nodes
if we reverse the graph(reverse all the edges), terminal node is one with 0 indegree
in reversed graph, if there is only 1 edge from a safe node to next node, next node is safe
we start from terminal nodes, and mark next node as safe it its indegree is 1
update the indegree of next node and continue, till all nodes with 0 indegree are done.

observations are -&gt; if there is no cycle, all nodes are safe
for a cycle all nodes are unsafe

this is kahns algorithm, which starts with nodes of 0 indegree, and keeps updating next nodes indegree.
kahns algorithm never enters a cycle, only nodes which are not part of a cycle are visited
Suppose there is a cycle, 0&lt;-&gt;1, but 1 is also connected to some node outside cycle
1&lt;-3 . Then indegree of 1 is 2, and whenever we will visit it from outside the cycle, 1s indegree will not become 0, and it will never becom a starting point in Kahns algorithm.
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Find Eventual Safe States" lines
# @param {Integer[][]} graph
# @return {Integer[]}
def eventual_safe_nodes(graph)
  n = graph.size
  reverse_graph = Hash.new {|h,k| h[k]=[]}
  graph.each_with_index {|edges, u| edges.each {|v| reverse_graph[v]<<u  } }
  indegree = graph.map(&:size) # indegree of nodes in the reverse graph

  is_safe_node = Array.new(n, false)
  queue = (0...n).select { |i| indegree[i]==0 } # initial starting nodes
  
  until queue.empty?
    node = queue.pop
    is_safe_node[node] = true

    reverse_graph[node].each do |neighbor|
      indegree[neighbor]-=1
      queue << neighbor if indegree[neighbor]==0
    end
  end

  (0...n).select{|x| is_safe_node[x]}
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>