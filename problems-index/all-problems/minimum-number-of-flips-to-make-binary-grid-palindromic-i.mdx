---
title: "ðŸ§€ Minimum Number of Flips to Make Binary Grid Palindromic I"
description: '[leetcode link](https://leetcode.com/problems/minimum-number-of-flips-to-make-binary-grid-palindromic-i/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given an <code>m x n</code> binary matrix <code>grid</code>.</p>  <p>A row or column is considered <strong>palindromic</strong> if its values read the same forward and backward.</p>  <p>You can <strong>flip</strong> any number of cells in <code>grid</code> from <code>0</code> to <code>1</code>, or from <code>1</code> to <code>0</code>.</p>  <p>Return the <strong>minimum</strong> number of cells that need to be flipped to make <strong>either</strong> all rows <strong>palindromic</strong> or all columns <strong>palindromic</strong>.</p>   <p><strong class="example">Example 1:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">grid = [[1,0,0],[0,0,0],[0,0,1]]</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">2</span></p>  <p><br/> <strong>Explanation:</strong></p>  <p><img alt="" src="https://assets.leetcode.com/uploads/2024/07/07/screenshot-from-2024-07-08-00-20-10.png" style="width: 420px; height: 108px;" /></p>  <p>Flipping the highlighted cells makes all the rows palindromic.</p> </div>  <p><strong class="example">Example 2:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">grid = </span>[[0,1],[0,1],[0,0]]</p>  <p><br/> <strong>Output:</strong> <span class="example-io">1</span></p>  <p><br/> <strong>Explanation:</strong></p>  <p><img alt="" src="https://assets.leetcode.com/uploads/2024/07/07/screenshot-from-2024-07-08-00-31-23.png" style="width: 300px; height: 100px;" /></p>  <p>Flipping the highlighted cell makes all the columns palindromic.</p> </div>  <p><strong class="example">Example 3:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">grid = [[1],[0]]</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">0</span></p>  <p><br/> <strong>Explanation:</strong></p>  <p>All rows are already palindromic.</p> </div>   <p><strong>Constraints:</strong></p>  <ul>  <li><code>m == grid.length</code></li>  <li><code>n == grid[i].length</code></li>  <li><code>1 &lt;= m * n &lt;= 2 * 10<sup>5</sup></code></li>  <li><code>0 &lt;= grid[i][j] &lt;= 1</code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Making each row or col palindrome is independent of other rows or cols. Get ops count for both all-row and all-col palindrome and pick min. To get palindrome op count for any array.
Just iterate and check mirror idxs, if they are different, 1 op is needed to make them match.

We can also just check no. of 1 and 0s in the array, to check how many ops are needed to make it palindrome.
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Minimum Number of Flips to Make Binary Grid Palindromic I" lines
# @param {Integer[][]} grid
# @return {Integer}
def min_flips(grid)
  m = grid.size
  n = grid[0].size

  # all row palindrome ops
  row_palindrome = grid.map {|row| ops_to_make_arr_palindrome(row) }.sum

  # all col palindrome ops
  col_palindrome = (0...n).map {|j| ops_to_make_arr_palindrome((0...m).map {|r| grid[r][j]}) }.sum

  [row_palindrome, col_palindrome].min
end

def ops_to_make_arr_palindrome(arr)
  n = arr.size
  (0..(n/2-1)).map {|i| arr[i]!=arr[n-1-i] ? 1 : 0}.sum
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>