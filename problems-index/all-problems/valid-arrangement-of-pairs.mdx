---
title: "❗️ Valid Arrangement of Pairs"
description: '[leetcode link](https://leetcode.com/problems/valid-arrangement-of-pairs/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given a <strong>0-indexed</strong> 2D integer array <code>pairs</code> where <code>pairs[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>. An arrangement of <code>pairs</code> is <strong>valid</strong> if for every index <code>i</code> where <code>1 &lt;= i &lt; pairs.length</code>, we have <code>end<sub>i-1</sub> == start<sub>i</sub></code>.</p>  <p>Return <em><strong>any</strong> valid arrangement of </em><code>pairs</code>.</p>  <p><strong>Note:</strong> The inputs will be generated such that there exists a valid arrangement of <code>pairs</code>.</p>   <p><strong class="example">Example 1:</strong></p>   <strong>Input:</strong> pairs = [[5,1],[4,5],[11,9],[9,4]] <br/> <strong>Output:</strong> [[11,9],[9,4],[4,5],[5,1]] <strong>Explanation: </strong>This is a valid arrangement since end<sub>i-1</sub> always equals start<sub>i</sub>. end<sub>0</sub> = 9 == 9 = start<sub>1</sub>  end<sub>1</sub> = 4 == 4 = start<sub>2</sub> end<sub>2</sub> = 5 == 5 = start<sub>3</sub>   <p><strong class="example">Example 2:</strong></p>   <strong>Input:</strong> pairs = [[1,3],[3,2],[2,1]] <br/> <strong>Output:</strong> [[1,3],[3,2],[2,1]] <br/> <strong>Explanation:</strong> This is a valid arrangement since end<sub>i-1</sub> always equals start<sub>i</sub>. end<sub>0</sub> = 3 == 3 = start<sub>1</sub> end<sub>1</sub> = 2 == 2 = start<sub>2</sub> The arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.   <p><strong class="example">Example 3:</strong></p>   <strong>Input:</strong> pairs = [[1,2],[1,3],[2,1]] <br/> <strong>Output:</strong> [[1,2],[2,1],[1,3]] <br/> <strong>Explanation:</strong> This is a valid arrangement since end<sub>i-1</sub> always equals start<sub>i</sub>. end<sub>0</sub> = 2 == 2 = start<sub>1</sub> end<sub>1</sub> = 1 == 1 = start<sub>2</sub>    <p><strong>Constraints:</strong></p>  <ul>  <li><code>1 &lt;= pairs.length &lt;= 10<sup>5</sup></code></li>  <li><code>pairs[i].length == 2</code></li>  <li><code>0 &lt;= start<sub>i</sub>, end<sub>i</sub> &lt;= 10<sup>9</sup></code></li>  <li><code>start<sub>i</sub> != end<sub>i</sub></code></li>  <li>No two pairs are exactly the same.</li>  <li>There <strong>exists</strong> a valid arrangement of <code>pairs</code>.</li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      its given that there exists a valid arrangement
  if there is no in-degree, that has to be start
  if there is no out-degree , that has to be end
  
  there are 3 kinds of nodes, start, link, end
  for all links, in-degree and out-degree have to be same; in=out
  for start, it can also be a link ahead, so subtracting those values, max 1 out should remain, i.e, out = in+1
  for end, it can be a link ahead, subtracting those, max 1 in should remain, ie. in = out+1 or more
  then as its given 1 solution exists, we can always connect these, so once we identify start point
  if all nodes have in-out, then any point can be starting point, its a closed loop
  then we can just keep going further, and we know there will always be an edge connecting further, as for the   rest in matches out, so we will reach the end
see editorial to understand further through diagram, and why we do postorder dfs
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Valid Arrangement of Pairs" lines
# @param {Integer[][]} pairs
# @return {Integer[][]}
def valid_arrangement(pairs)
  n = pairs.size
  adj_h = Hash.new {|h,k| h[k]=[]}
  in_degree = Hash.new(0); out_degree = Hash.new(0);
  pairs.each { |u,v| adj_h[u]<<v; in_degree[v]+=1; out_degree[u]+=1; }
  start_node = out_degree.keys.detect {|node| out_degree[node] == in_degree[node]+1 } || pairs[0][0]
  nodes = []

  dfs=->(node){
    dfs.call(adj_h[node].pop) until adj_h[node].empty?
    nodes << node
  }
  
  dfs.call(start_node)
  nodes.reverse!

  (1..n).map { |i| [nodes[i-1], nodes[i]] }
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>