---
title: 'ðŸ§€ Make Lexicographically Smallest Array by Swapping Elements'
description: '[leetcode link](https://leetcode.com/problems/make-lexicographically-smallest-array-by-swapping-elements/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given a <strong>0-indexed</strong> array of <strong>positive</strong> integers <code>nums</code> and a <strong>positive</strong> integer <code>limit</code>.</p>  <p>In one operation, you can choose any two indices <code>i</code> and <code>j</code> and swap <code>nums[i]</code> and <code>nums[j]</code> <strong>if</strong> <code>|nums[i] - nums[j]| &lt;= limit</code>.</p>  <p>Return <em>the <strong>lexicographically smallest array</strong> that can be obtained by performing the operation any number of times</em>.</p>  <p>An array <code>a</code> is lexicographically smaller than an array <code>b</code> if in the first position where <code>a</code> and <code>b</code> differ, array <code>a</code> has an element that is less than the corresponding element in <code>b</code>. For example, the array <code>[2,10,3]</code> is lexicographically smaller than the array <code>[10,2,3]</code> because they differ at index <code>0</code> and <code>2 &lt; 10</code>.</p>   <p><strong class="example">Example 1:</strong></p>   <strong>Input:</strong> nums = [1,5,3,9,8], limit = 2 <br/> <strong>Output:</strong> [1,3,5,8,9] <br/> <strong>Explanation:</strong> Apply the operation 2 times: - Swap nums[1] with nums[2]. The array becomes [1,3,5,9,8] - Swap nums[3] with nums[4]. The array becomes [1,3,5,8,9] We cannot obtain a lexicographically smaller array by applying any more operations. Note that it may be possible to get the same result by doing different operations.   <p><strong class="example">Example 2:</strong></p>   <strong>Input:</strong> nums = [1,7,6,18,2,1], limit = 3 <br/> <strong>Output:</strong> [1,6,7,18,1,2] <br/> <strong>Explanation:</strong> Apply the operation 3 times: - Swap nums[1] with nums[2]. The array becomes [1,6,7,18,2,1] - Swap nums[0] with nums[4]. The array becomes [2,6,7,18,1,1] - Swap nums[0] with nums[5]. The array becomes [1,6,7,18,1,2] We cannot obtain a lexicographically smaller array by applying any more operations.   <p><strong class="example">Example 3:</strong></p>   <strong>Input:</strong> nums = [1,7,28,19,10], limit = 3 <br/> <strong>Output:</strong> [1,7,28,19,10] <br/> <strong>Explanation:</strong> [1,7,28,19,10] is the lexicographically smallest array we can obtain because we cannot apply the operation on any two indices.    <p><strong>Constraints:</strong></p>  <ul>  <li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>  <li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>  <li><code>1 &lt;= limit &lt;= 10<sup>9</sup></code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      [1,7,6,18,2,1], answer is [1,6,7,18,1,2]
sorted array is lexicographically smallest [1,1,2,6,7,18]; we want smaller elements to move to left;
sorting done by swapping is kind of like bubble sort, pick and move element to its position.
If its allowed to swap i and j, and swap j and k, then there is an algorithm to swap i and k. Formally, for a sb_arr, such that sorted_sb_arr has no two consecutive elements have diff more than limit, lets call it special sb_arr
no matter the initial ordering of this array, we can arrive to sorted_sb_arr, by chaining swaps.
consider, [5, 3, 1] and limit=2, 1,5 cant be swapped directly, but 3 can be used to to eventually reach [1,3,5]
by doing following swaps [1,3] [3,5] and [5,1]

now, in the original array, we create sorted_arr, and break it into groups of special_sb_arrs. 
all no.s within a special_sb_arr will be sorted in the result
So suppose arr = [a1, b2, a3, a2, c1, c3, b1, c2]; special_sb_arrs = [a1,a2,a3] + [b1,b2] + [c1,c2,c3]
with special_sb_arrs being a, b & c. Suppose we look at special_sb_arrs a, original idxs are a1-0,a2-3,a3-2. final idxs of special_sb_arr a would be a1-0,a2-2,a3-3.

Note, max element from special_sb_1 cant be swapped with min of special_sb_2, so these 2 groups will not see any swaps, or reordering of original idxs will only happen within idxs of each special_sb_arr.

To do this, create special_sb_arrs from sorted_nums, and for each special_sb_arr, the indexes that make up that special_sb_arr. Now for each sb_arr, elements will have their new indexes. Suppose sb_arr = [a1, a2, a3]. Original idxs are [idx2, idx3, idx1] with a1 having index idx2 in original arr. In the output array a1 will have idx1, a2 will have idx2, a3 will have idx3, assuming sorted order of idxs is [idx1, idx2, idx3]. So for each subarray [num, new_i ] is sb_arr.zip(sb_arr_idxs.sort).

    </Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Make Lexicographically Smallest Array by Swapping Elements" lines
# @param {Integer[]} nums
# @param {Integer} limit
# @return {Integer[]}
def lexicographically_smallest_array(nums, limit)
  sorted_nums = nums.each_with_index.sort
  special_sb_arrs = []
  special_sb_arr_idxs = []
  sorted_nums.each do |num, i|
    if special_sb_arrs.last.nil? || (num-special_sb_arrs.last.last) > limit # start new special sb arr
      special_sb_arrs << [num]; special_sb_arr_idxs << [i]
    else
      special_sb_arrs.last << num; special_sb_arr_idxs.last << i
    end
  end
  sorted_sb_arr_idxs = special_sb_arr_idxs.map(&:sort) # sort each group of special_sb_arr idxs, these will be final ordering of indexes within the sb_arr
  special_sb_arrs.flatten.zip(sorted_sb_arr_idxs.flatten).sort_by(&:last).map(&:first) # [num,new_i] after zip, each num has its new index.
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>