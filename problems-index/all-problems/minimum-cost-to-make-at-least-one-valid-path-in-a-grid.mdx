---
title: '❗️ Minimum Cost to Make at Least One Valid Path in a Grid'
description: '[leetcode link](https://leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>Given an <code>m x n</code> grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of <code>grid[i][j]</code> can be:</p>  <ul>  <li><code>1</code> which means go to the cell to the right. (i.e go from <code>grid[i][j]</code> to <code>grid[i][j + 1]</code>)</li>  <li><code>2</code> which means go to the cell to the left. (i.e go from <code>grid[i][j]</code> to <code>grid[i][j - 1]</code>)</li>  <li><code>3</code> which means go to the lower cell. (i.e go from <code>grid[i][j]</code> to <code>grid[i + 1][j]</code>)</li>  <li><code>4</code> which means go to the upper cell. (i.e go from <code>grid[i][j]</code> to <code>grid[i - 1][j]</code>)</li> </ul>  <p>Notice that there could be some signs on the cells of the grid that point outside the grid.</p>  <p>You will initially start at the upper left cell <code>(0, 0)</code>. A valid path in the grid is a path that starts from the upper left cell <code>(0, 0)</code> and ends at the bottom-right cell <code>(m - 1, n - 1)</code> following the signs on the grid. The valid path does not have to be the shortest.</p>  <p>You can modify the sign on a cell with <code>cost = 1</code>. You can modify the sign on a cell <strong>one time only</strong>.</p>  <p>Return <em>the minimum cost to make the grid have at least one valid path</em>.</p>   <p><strong class="example">Example 1:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2020/02/13/grid1.png" style="width: 400px; height: 390px;" />  <strong>Input:</strong> grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]] <br/> <strong>Output:</strong> 3 <br/> <strong>Explanation:</strong> You will start at point (0, 0). The path to (3, 3) is as follows. (0, 0) --&gt; (0, 1) --&gt; (0, 2) --&gt; (0, 3) change the arrow to down with cost = 1 --&gt; (1, 3) --&gt; (1, 2) --&gt; (1, 1) --&gt; (1, 0) change the arrow to down with cost = 1 --&gt; (2, 0) --&gt; (2, 1) --&gt; (2, 2) --&gt; (2, 3) change the arrow to down with cost = 1 --&gt; (3, 3) The total cost = 3.   <p><strong class="example">Example 2:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2020/02/13/grid2.png" style="width: 350px; height: 341px;" />  <strong>Input:</strong> grid = [[1,1,3],[3,2,2],[1,1,4]] <br/> <strong>Output:</strong> 0 <br/> <strong>Explanation:</strong> You can follow the path from (0, 0) to (2, 2).   <p><strong class="example">Example 3:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2020/02/13/grid3.png" style="width: 200px; height: 192px;" />  <strong>Input:</strong> grid = [[1,2],[4,3]] <br/> <strong>Output:</strong> 1    <p><strong>Constraints:</strong></p>  <ul>  <li><code>m == grid.length</code></li>  <li><code>n == grid[i].length</code></li>  <li><code>1 &lt;= m, n &lt;= 100</code></li>  <li><code>1 &lt;= grid[i][j] &lt;= 4</code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      bfs from (0,0), each cell has 4 edges, with only 1 edge having 0 weight,rest having 1.

Do Shortest path, allowing visiting more than once, and update minimum distance. Also process 0 edges first, so Djikstra, but here only 2 values are possible for edges. So use a deque, put 0s first and 1s last, and pick from first always.
    </Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Minimum Cost to Make at Least One Valid Path in a Grid" lines
# @param {Integer[][]} grid
# @return {Integer}
def min_cost(grid)
  m = grid.size; n = grid[0].size
  # m-1, n-1 value has to be ignored. 
  # bfs from (0,0), each cell has 4 edges, with only 1 edge having 0 weight,rest having 1
  # process 0 weights first while doing the bfs, and maintain dist.
  queue = [[0,0,0]]
  dist = Array.new(m) { Array.new(n, Float::INFINITY) } # will maintain mindist for x,y
  dist[0][0]=0
  directions = [[0,1], [0,-1], [1,0], [-1,0]]

  neighbors=->(x,y) {
    directions.each_with_index.map {|(n_i,n_j),idx| 
      ((x+n_i).between?(0,m-1) && (y+n_j).between?(0,n-1)) ? [x+n_i, y+n_j, idx==grid[x][y]-1 ? 0:1] : nil
    }.compact
  }

  until queue.empty?
    i,j,d = queue.shift # pick from start of queue always
    next if dist[i][j] < d # current path with d cost is not optimal
  
    neighbors.call(i,j).each do |x,y,w|
      if dist[x][y] > d+w 
        dist[x][y] = d+w
        w ==1 ? queue.push([x,y,d+w]) : queue.unshift([x,y,d+w])
      end
    end
  end
  
  dist[m-1][n-1]
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>