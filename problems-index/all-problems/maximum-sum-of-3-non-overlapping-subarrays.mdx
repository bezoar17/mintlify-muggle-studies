---
title: "❗️ Maximum Sum of 3 Non-Overlapping Subarrays"
description: '[leetcode link](https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>Given an integer array <code>nums</code> and an integer <code>k</code>, find three non-overlapping subarrays of length <code>k</code> with maximum sum and return them.</p>  <p>Return the result as a list of indices representing the starting position of each interval (<strong>0-indexed</strong>). If there are multiple answers, return the lexicographically smallest one.</p>   <p><strong class="example">Example 1:</strong></p>   <strong>Input:</strong> nums = [1,2,1,2,6,7,5,1], k = 2 <br/> <strong>Output:</strong> [0,3,5] <br/> <strong>Explanation:</strong> Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5]. We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.   <p><strong class="example">Example 2:</strong></p>   <strong>Input:</strong> nums = [1,2,1,2,1,2,1,2,1], k = 2 <br/> <strong>Output:</strong> [0,2,4]    <p><strong>Constraints:</strong></p>  <ul>  <li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>  <li><code>1 &lt;= nums[i] &lt;&nbsp;2<sup>16</sup></code></li>  <li><code>1 &lt;= k &lt;= floor(nums.length / 3)</code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      or left[i] is max-subarray of k till i.
  right[i] is max-subarray sum of k from [i+1..]
	
	Then we can try all mid subarray of k ending at idx where idx can be from 2k-1, and at most can be n-k-1. 
	For this mid_pos, where middle subarray is ending, max sum is, left[1st subarray is till mid_pos-k] +  right[mid_pos+1] + mid_sb_sum.
	
	We calculate all possible mid idxs, and store the max and indices for this.
	
	For lex smallest, for L-&gt;R movement, we update max only when greater, from R-&gt;L,  we update max when also when its equal to current sum.
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Maximum Sum of 3 Non-Overlapping Subarrays" lines
# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer[]}
# Read-Only for queries of sum of [l,r]
# pseudo_tree.query(l, r+1)

class PseudoSumSegTree
  def initialize(arr)
    @n = arr.size # size of the source array
    # query can have r till n, so sum of all elements is at prefix[n]
    @prefix_sum_arr = (1..@n).reduce([0]) {|res, i| res << res.last + arr[i-1]; res } # sum till i-1
  end
  
  # [l,r)
  def query(l,r)
    @prefix_sum_arr[r] - @prefix_sum_arr[l]
  end
end


def max_sum_of_three_subarrays(nums, k)
  # see note for explanation
  n = nums.size
  psg = PseudoSumSegTree.new(nums) # query gives result for [l,r)
  left_max_at_i = Array.new(n, [-Float::INFINITY,-1])
  right_max_at_i = Array.new(n+1, [-Float::INFINITY,-1])

  ((k-1)...n).each do |i|
    sb_sum = psg.query(i-k+1,i+1)
    # for lexicographically smallest, left should be updated only on >
    left_max_at_i[i] = (sb_sum > left_max_at_i[i-1][0]) ? [sb_sum, i-k+1] : left_max_at_i[i-1]
  end

  (n-k).downto(0).each do |i|
    sb_sum = psg.query(i, i+k)
    # for lexicographically smallest, right should be updated on = too
    right_max_at_i[i] = (sb_sum >= right_max_at_i[i+1][0]) ? [sb_sum, i] : right_max_at_i[i+1]
  end

  max_3sb_sum = 0; idxs = [];
  mid_pos_range = (2*k-1)..(n-k-1)
  
  mid_pos_range.each do |mid_pos|
    mid_sb_sum = psg.query(mid_pos-k+1, mid_pos+1)
    sb3_sum = left_max_at_i[mid_pos-k][0] + mid_sb_sum + right_max_at_i[mid_pos+1][0]
    if sb3_sum > max_3sb_sum
      max_3sb_sum=sb3_sum
      idxs = [left_max_at_i[mid_pos-k][1], mid_pos-k+1, right_max_at_i[mid_pos+1][1]]
    end
  end
  idxs
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>