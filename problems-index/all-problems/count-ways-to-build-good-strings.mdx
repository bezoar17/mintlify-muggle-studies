---
title: "ðŸ§€ Count Ways To Build Good Strings"
description: '[leetcode link](https://leetcode.com/problems/count-ways-to-build-good-strings/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>Given the integers <code>zero</code>, <code>one</code>, <code>low</code>, and <code>high</code>, we can construct a string by starting with an empty string, and then at each step perform either of the following:</p>  <ul>  <li>Append the character <code>&#39;0&#39;</code> <code>zero</code> times.</li>  <li>Append the character <code>&#39;1&#39;</code> <code>one</code> times.</li> </ul>  <p>This can be performed any number of times.</p>  <p>A <strong>good</strong> string is a string constructed by the above process having a <strong>length</strong> between <code>low</code> and <code>high</code> (<strong>inclusive</strong>).</p>  <p>Return <em>the number of <strong>different</strong> good strings that can be constructed satisfying these properties.</em> Since the answer can be large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>   <p><strong class="example">Example 1:</strong></p>   <strong>Input:</strong> low = 3, high = 3, zero = 1, one = 1 <br/> <strong>Output:</strong> 8 <br/> <strong>Explanation:</strong>  One possible valid good string is &quot;011&quot;.  It can be constructed as follows: &quot;&quot; -&gt; &quot;0&quot; -&gt; &quot;01&quot; -&gt; &quot;011&quot;.  All binary strings from &quot;000&quot; to &quot;111&quot; are good strings in this example.   <p><strong class="example">Example 2:</strong></p>   <strong>Input:</strong> low = 2, high = 3, zero = 1, one = 2 <br/> <strong>Output:</strong> 5 <br/> <strong>Explanation:</strong> The good strings are &quot;00&quot;, &quot;11&quot;, &quot;000&quot;, &quot;110&quot;, and &quot;011&quot;.    <p><strong>Constraints:</strong></p>  <ul>  <li><code>1 &lt;= low&nbsp;&lt;= high&nbsp;&lt;= 10<sup>5</sup></code></li>  <li><code>1 &lt;= zero, one &lt;= low</code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Just like climb stairs and decode ways(conditional fibonacci), here instead of -1 and -2, its -zero and -one, but concept is the same and because its random no.s, bottom up might be difficult to build, so top-down with memo works.
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Count Ways To Build Good Strings" lines
# @param {Integer} low
# @param {Integer} high
# @param {Integer} zero
# @param {Integer} one
# @return {Integer}
def count_good_strings(low, high, zero, one)
    @cache = {}
    @zero, @one = zero, one
    @mod = 1000000007

    total = 0
    (low..high).each { |i| total += good_strings(i) }
    total % @mod
end

def good_strings(i)
    return 0 if i < 0
    return 1 if i == 0

    @cache[i] ||= (good_strings(i - @zero) + good_strings(i - @one)) % @mod
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>