---
title: 'ðŸ§€ Diagonal Traverse'
description: '[leetcode link](https://leetcode.com/problems/diagonal-traverse/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>Given an <code>m x n</code> matrix <code>mat</code>, return <em>an array of all the elements of the array in a diagonal order</em>.</p>   <p><strong class="example">Example 1:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2021/04/10/diag1-grid.jpg" style="width: 334px; height: 334px;" />  <strong>Input:</strong> mat = [[1,2,3],[4,5,6],[7,8,9]] <br/> <strong>Output:</strong> [1,2,4,7,5,3,6,8,9]   <p><strong class="example">Example 2:</strong></p>   <strong>Input:</strong> mat = [[1,2],[3,4]] <br/> <strong>Output:</strong> [1,2,3,4]    <p><strong>Constraints:</strong></p>  <ul>  <li><code>m == mat.length</code></li>  <li><code>n == mat[i].length</code></li>  <li><code>1 &lt;= m, n &lt;= 10<sup>4</sup></code></li>  <li><code>1 &lt;= m * n &lt;= 10<sup>4</sup></code></li>  <li><code>-10<sup>5</sup> &lt;= mat[i][j] &lt;= 10<sup>5</sup></code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Elements on same diagonal have same i+j value. Then, diagonals with i+j being odd have normal direction, ones with even value have to be sent in reverse. Simply store and push out accordingly.

If O(1) space is required, we have to use direction to indicate current diagonal being processed. Up or down, based on that next element is decided, then if its out of range, we have to flip direction, and choose the next element, that calculation is again dependent on next element being in range, dry run it, and it can be solved.

    </Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Diagonal Traverse" lines
# @param {Integer[][]} mat
# @return {Integer[]}
def find_diagonal_order(mat)
  # m = mat.size; n = mat[0].size
  # diag_h = Hash.new {|h,k| h[k]=[]}
  # (0...m).each { |i| (0...n).each { |j| diag_h[i+j] << mat[i][j] } }
  # diag_h.keys.sort.map {|i| i.odd? ? diag_h[i] : diag_h[i].reverse }.flatten
  
  find_diagonal_order2(mat)
end

# O(1) space
def find_diagonal_order2(mat)
  m = mat.size; n = mat[0].size
  i = j = 0
  dir = 1 # up, -1 is down
  result = []
  while i < m && j < n
    result << mat[i][j]

    next_i = i + dir*-1 # next in direction
    next_j = j + dir

    if next_i.between?(0, m-1) && next_j.between?(0,n-1)
      i = next_i; j = next_j # if next is within range, for up, it can go above 0th row
    else
      # for up dir, if we are at 0th row, move right, if cant move right go down for next elem
      # so next is (i,j+1) if within range, else (i+1,j), similarly for the other direction
      if dir == 1
        i+= j == n-1 ? 1 : 0 
        j+= j < n-1 ? 1 : 0
      else
        j+= i == m-1 ? 1 : 0
        i+= i < m-1 ? 1 : 0
      end
      dir*= -1 # flip the direction
    end
  end

  result
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>