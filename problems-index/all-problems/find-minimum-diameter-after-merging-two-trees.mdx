---
title: '❗️ Find Minimum Diameter After Merging Two Trees'
description: '[leetcode link](https://leetcode.com/problems/find-minimum-diameter-after-merging-two-trees/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>There exist two <strong>undirected </strong>trees with <code>n</code> and <code>m</code> nodes, numbered from <code>0</code> to <code>n - 1</code> and from <code>0</code> to <code>m - 1</code>, respectively. You are given two 2D integer arrays <code>edges1</code> and <code>edges2</code> of lengths <code>n - 1</code> and <code>m - 1</code>, respectively, where <code>edges1[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the first tree and <code>edges2[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> indicates that there is an edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> in the second tree.</p>  <p>You must connect one node from the first tree with another node from the second tree with an edge.</p>  <p>Return the <strong>minimum </strong>possible <strong>diameter </strong>of the resulting tree.</p>  <p>The <strong>diameter</strong> of a tree is the length of the <em>longest</em> path between any two nodes in the tree.</p>   <p><strong class="example">Example 1:</strong><img alt="" src="https://assets.leetcode.com/uploads/2024/04/22/example11-transformed.png" /></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">edges1 = [[0,1],[0,2],[0,3]], edges2 = [[0,1]]</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">3</span></p>  <p><br/> <strong>Explanation:</strong></p>  <p>We can obtain a tree of diameter 3 by connecting node 0 from the first tree with any node from the second tree.</p> </div>  <p><strong class="example">Example 2:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2024/04/22/example211.png" /> <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">edges1 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]], edges2 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]]</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">5</span></p>  <p><br/> <strong>Explanation:</strong></p>  <p>We can obtain a tree of diameter 5 by connecting node 0 from the first tree with node 0 from the second tree.</p> </div>   <p><strong>Constraints:</strong></p>  <ul>  <li><code>1 &lt;= n, m &lt;= 10<sup>5</sup></code></li>  <li><code>edges1.length == n - 1</code></li>  <li><code>edges2.length == m - 1</code></li>  <li><code>edges1[i].length == edges2[i].length == 2</code></li>  <li><code>edges1[i] = [a<sub>i</sub>, b<sub>i</sub>]</code></li>  <li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>  <li><code>edges2[i] = [u<sub>i</sub>, v<sub>i</sub>]</code></li>  <li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; m</code></li>  <li>The input is generated such that <code>edges1</code> and <code>edges2</code> represent valid trees.</li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Merge center of both diameters of T1 and T2, we have new_diameter. Answer max of new_diameter, diameter_t1, diameter_t2.
When diameter is odd, we pick ceil value for radius.

To calculate diameter of tree, similar to that of binary tree, start from any node, assume that to be root. Calculate max depth for all children. max diameter if this is center is sum of 2 max in max_depth value for all children. max depth function will run for all nodes, hence diameter calculation assuming node is center is done for all nodes if put in this function. 
    </Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Find Minimum Diameter After Merging Two Trees" lines
# @param {Integer[][]} edges1
# @param {Integer[][]} edges2
# @return {Integer}
def minimum_diameter_after_merge(edges1, edges2)
  # merge
  d1 = diameter_of_tree(edges1)
  d2 = diameter_of_tree(edges2)
  new_d = (d1/2.0).ceil + 1 + (d2/2.0).ceil
  [d1,d2,new_d].max
end

def diameter_of_tree(edges)
  diameter = 0; n = edges.size+1
  adj_h = Hash.new {|h,k| h[k]=[]}; edges.each {|u,v| adj_h[u]<<v; adj_h[v]<<u;}
  
  max_depth =->(node, parent) {
    return 0 if node.nil?
    children = adj_h[node].select {|x| x!=parent }
    sorted_children_depths = children.map { |ch| max_depth.call(ch, node) }.sort
    diameter = [diameter, sorted_children_depths.last(2).sum].max
    1 + sorted_children_depths[-1].to_i
  }

  max_depth.call(0, nil)
  diameter
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>