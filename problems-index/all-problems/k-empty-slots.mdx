---
title: "❗️ K Empty Slots"
description: '[leetcode link](https://leetcode.com/problems/k-empty-slots/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You have <code>n</code> bulbs in a row numbered from <code>1</code> to <code>n</code>. Initially, all the bulbs are turned off. We turn on <strong>exactly one</strong> bulb every day until all bulbs are on after <code>n</code> days.</p>  <p>You are given an array <code>bulbs</code>&nbsp;of length <code>n</code>&nbsp;where <code>bulbs[i] = x</code> means that on the <code>(i+1)<sup>th</sup></code> day, we will turn on the bulb at position <code>x</code>&nbsp;where&nbsp;<code>i</code>&nbsp;is&nbsp;<strong>0-indexed</strong>&nbsp;and&nbsp;<code>x</code>&nbsp;is&nbsp;<strong>1-indexed.</strong></p>  <p>Given an integer <code>k</code>, return&nbsp;<em>the <strong>minimum day number</strong> such that there exists two <strong>turned on</strong> bulbs that have <strong>exactly</strong>&nbsp;<code>k</code> bulbs between them that are <strong>all turned off</strong>. If there isn&#39;t such day, return <code>-1</code>.</em></p>   <p><strong class="example">Example 1:</strong></p>   <strong>Input:</strong> bulbs = [1,3,2], k = 1 <br/> <strong>Output:</strong> 2 <b>Explanation:</b> On the first day: bulbs[0] = 1, first bulb is turned on: [1,0,0] On the second day: bulbs[1] = 3, third bulb is turned on: [1,0,1] On the third day: bulbs[2] = 2, second bulb is turned on: [1,1,1] We return 2 because on the second day, there were two on bulbs with one off bulb between them.  <p><strong class="example">Example 2:</strong></p>   <strong>Input:</strong> bulbs = [1,2,3], k = 1 <br/> <strong>Output:</strong> -1    <p><strong>Constraints:</strong></p>  <ul>  <li><code>n == bulbs.length</code></li>  <li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>  <li><code>1 &lt;= bulbs[i] &lt;= n</code></li>  <li><code>bulbs</code>&nbsp;is a permutation of numbers from&nbsp;<code>1</code>&nbsp;to&nbsp;<code>n</code>.</li>  <li><code>0 &lt;= k &lt;= 2 * 10<sup>4</sup></code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Create an array, where each bulbs idx has the day it will light up. Now think of finding 2 boundaries left, right, such that there is some day when all between them were off. i.e, all bulbs in between will turn on later than left and right. So, min of all bulbs in between is &gt; max of left and right.

left, right is always separated by k, so we just slide this window and calculate it.

For min of all bulbs, we can just check if all bulbs within the window are &gt; boundary_max day.
If yes, we record the answer, and shift the window.
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="K Empty Slots" lines
# @param {Integer[]} bulbs
# @param {Integer} k
# @return {Integer}
def k_empty_slots(bulbs, k)
  n = bulbs.size
  on_days = [0] * n
  bulbs.each_with_index { |b_idx,d| on_days[b_idx-1] = d+1 }

  earliest_valid_day = Float::INFINITY

  left = 0
  right = left + k + 1

  on_days.each_with_index do |bulb_on_day, idx|
    break if right >= n
    
    boundary_max_day = [on_days[left], on_days[right]].max

    next if bulb_on_day > boundary_max_day # this bulb within window is valid

    # we have reached end of window, means all bulbs in window were valid
    earliest_valid_day = [boundary_max_day, earliest_valid_day].min if idx == right

    # some invalid bulb found at idx, update window, with left to be updated to this idx
    # as all from 0 to idx cant be starting points because of idx value being less than
    # boundary_max, and all rest being > boundary_max, hence they were valid
    left = idx
    right = left + k + 1
  end

  earliest_valid_day == Float::INFINITY ? -1 : earliest_valid_day
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>