---
title: "ðŸ§€ Longest Nice Subarray"
description: '[leetcode link](https://leetcode.com/problems/longest-nice-subarray/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given an array <code>nums</code> consisting of <strong>positive</strong> integers.</p>  <p>We call a subarray of <code>nums</code> <strong>nice</strong> if the bitwise <strong>AND</strong> of every pair of elements that are in <strong>different</strong> positions in the subarray is equal to <code>0</code>.</p>  <p>Return <em>the length of the <strong>longest</strong> nice subarray</em>.</p>  <p>A <strong>subarray</strong> is a <strong>contiguous</strong> part of an array.</p>  <p><strong>Note</strong> that subarrays of length <code>1</code> are always considered nice.</p>   <p><strong class="example">Example 1:</strong></p>   <strong>Input:</strong> nums = [1,3,8,48,10] <br/> <strong>Output:</strong> 3 <br/> <strong>Explanation:</strong> The longest nice subarray is [3,8,48]. This subarray satisfies the conditions: - 3 AND 8 = 0. - 3 AND 48 = 0. - 8 AND 48 = 0. It can be proven that no longer nice subarray can be obtained, so we return 3.  <p><strong class="example">Example 2:</strong></p>   <strong>Input:</strong> nums = [3,1,5,11,13] <br/> <strong>Output:</strong> 1 <br/> <strong>Explanation:</strong> The length of the longest nice subarray is 1. Any subarray of length 1 can be chosen.    <p><strong>Constraints:</strong></p>  <ul>  <li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>  <li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Within a nice sub-array, a, b, c. While adding b, we need all set bits of a are 0 in b. Then, for c, all set bits of a and b should be 0. And so, on. So, when new element is added, it cant have the same set bit as any other elements in the window.

To include element we use OR. 
To check overlap we do AND and see if its non-zero, some overlap of set bits is present.
To reduce window from left, we XOR and remove the leftmost element until we have no overlap.
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Longest Nice Subarray" lines
# @param {Integer[]} nums
# @return {Integer}
def longest_nice_subarray(nums)
  ans = 0
  l = 0
  bitmask = 0
  nums.each_with_index do |num, r|
    while (bitmask & num) != 0
      bitmask ^= nums[l]
      l += 1
    end
    bitmask |= num
    ans = [ans, r - l + 1].max
  end
  ans
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>