---
title: "ðŸ§€ Maximum Difference Score in a Grid"
description: '[leetcode link](https://leetcode.com/problems/maximum-difference-score-in-a-grid/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given an <code>m x n</code> matrix <code>grid</code> consisting of <strong>positive</strong> integers. You can move from a cell in the matrix to <strong>any</strong> other cell that is either to the bottom or to the right (not necessarily adjacent). The score of a move from a cell with the value <code>c1</code> to a cell with the value <code>c2</code> is <code>c2 - c1</code>.</p>  <p>You can start at <strong>any</strong> cell, and you have to make <strong>at least</strong> one move.</p>  <p>Return the <strong>maximum</strong> total score you can achieve.</p>   <p><strong class="example">Example 1:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2024/03/14/grid1.png" style="width: 240px; height: 240px;" /> <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">grid = [[9,5,7,3],[8,9,6,1],[6,7,14,3],[2,5,3,1]]</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">9</span></p>  <p><br/> <strong>Explanation:</strong> We start at the cell <code>(0, 1)</code>, and we perform the following moves:<br /> - Move from the cell <code>(0, 1)</code> to <code>(2, 1)</code> with a score of <code>7 - 5 = 2</code>.<br /> - Move from the cell <code>(2, 1)</code> to <code>(2, 2)</code> with a score of <code>14 - 7 = 7</code>.<br /> The total score is <code>2 + 7 = 9</code>.</p> </div>  <p><strong class="example">Example 2:</strong></p>  <p><img alt="" src="https://assets.leetcode.com/uploads/2024/04/08/moregridsdrawio-1.png" style="width: 180px; height: 116px;" /></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">grid = [[4,3,2],[3,2,1]]</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">-1</span></p>  <p><br/> <strong>Explanation:</strong> We start at the cell <code>(0, 0)</code>, and we perform one move: <code>(0, 0)</code> to <code>(0, 1)</code>. The score is <code>3 - 4 = -1</code>.</p> </div>   <p><strong>Constraints:</strong></p>  <ul>  <li><code>m == grid.length</code></li>  <li><code>n == grid[i].length</code></li>  <li><code>2 &lt;= m, n &lt;= 1000</code></li>  <li><code>4 &lt;= m * n &lt;= 10<sup>5</sup></code></li>  <li><code>1 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      For any path with x1,y1 as starting and x2,y2 as ending. No matter how many jumps you make, score is difference of final-start values.

So, for each (i,j) calculate max score if we this cell is the last stop. To maximize score, we need to start at the minimum values in previous possible range, which is a square  where this cell is bottom-right corner, but excluding this cell. 

Then take the max of all scores calculated. 

To calculate all previous minimum values in the range. 

We can calculate prefix minimums row and column wise, using this we can store all minimums in range, and check them in O(1).

See the submission notes for code with explanation
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Maximum Difference Score in a Grid" lines
# @param {Integer[][]} grid
# @return {Integer}
def max_score(grid)
  m = grid.size
  n = grid[0].size

  # for any (i,j), value stored is minimum between 0,j to i-1,j
  # so its a col-wise prefixmin, similar rowise will is calculated down below, but on the fly
  prefix_min_in_col = [[Float::INFINITY] * n] + Array.new(m-1) { Array.new(n, Float::INFINITY) }

  (0...n).each do |j|
    (1...m).each do |i|
      last_row = i-1
      prefix_min_in_col[i][j] = [prefix_min_in_col[last_row][j], grid[last_row][j]].min
    end
  end

  # dp_mt for (i,j) stores min of all values in the square which has (i,j) as bottom-right corner
  dp_mt = Array.new(m) { Array.new(n) }

  result = -Float::INFINITY

  (0...m).each do |i|
    # calculate similar row wise prefix min on the fly, idx i has min value till i-1
    prefix_min_row = [Float::INFINITY]
    
    (0...n).each do |j|
      # dp_mt for (i-1,j-1). this square is on the top-left corner of the current cell (i,j)
      prev_corner_val = (i-1 <0 || j-1 < 0) ? Float::INFINITY : dp_mt[i-1][j-1]
      
      prefix_min_row << [prefix_min_row.last, grid[i][j-1] ].min if j > 0

      # all possible starting points from where we can jump to (i,j)
      # either from last square(i-1,j-1) or from the column above, or row to the left
      # which are calculated in prefix minimums for column and row
      all_prev_min = [prev_corner_val, prefix_min_in_col[i][j], prefix_min_row[j]].min

      # cost for this jump
      cost = grid[i][j] - all_prev_min

      result = [result, cost].max
      
      # update dp_mt value, it is all previous min and current'cells
      dp_mt[i][j] = [all_prev_min, grid[i][j]].min      
    end
  end

  result
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>