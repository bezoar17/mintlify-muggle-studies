---
title: '❗️ Peaks in Array'
description: '[leetcode link](https://leetcode.com/problems/peaks-in-array/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>A <strong>peak</strong> in an array <code>arr</code> is an element that is <strong>greater</strong> than its previous and next element in <code>arr</code>.</p>  <p>You are given an integer array <code>nums</code> and a 2D integer array <code>queries</code>.</p>  <p>You have to process queries of two types:</p>  <ul>  <li><code>queries[i] = [1, l<sub>i</sub>, r<sub>i</sub>]</code>, determine the count of <strong>peak</strong> elements in the <span data-keyword="subarray">subarray</span> <code>nums[l<sub>i</sub>..r<sub>i</sub>]</code>.<!-- notionvc: 73b20b7c-e1ab-4dac-86d0-13761094a9ae --></li>  <li><code>queries[i] = [2, index<sub>i</sub>, val<sub>i</sub>]</code>, change <code>nums[index<sub>i</sub>]</code> to <code><font face="monospace">val<sub>i</sub></font></code>.</li> </ul>  <p>Return an array <code>answer</code> containing the results of the queries of the first type in order.<!-- notionvc: a9ccef22-4061-4b5a-b4cc-a2b2a0e12f30 --></p>  <p><strong>Notes:</strong></p>  <ul>  <li>The <strong>first</strong> and the <strong>last</strong> element of an array or a subarray<!-- notionvc: fcffef72-deb5-47cb-8719-3a3790102f73 --> <strong>cannot</strong> be a peak.</li> </ul>   <p><strong class="example">Example 1:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">nums = [3,1,4,2,5], queries = [[2,3,4],[1,0,4]]</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">[0]</span></p>  <p><br/> <strong>Explanation:</strong></p>  <p>First query: We change <code>nums[3]</code> to 4 and <code>nums</code> becomes <code>[3,1,4,4,5]</code>.</p>  <p>Second query: The number of peaks in the <code>[3,1,4,4,5]</code> is 0.</p> </div>  <p><strong class="example">Example 2:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">nums = [4,1,4,2,1,5], queries = [[2,2,4],[1,0,2],[1,0,4]]</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">[0,1]</span></p>  <p><br/> <strong>Explanation:</strong></p>  <p>First query: <code>nums[2]</code> should become 4, but it is already set to 4.</p>  <p>Second query: The number of peaks in the <code>[4,1,4]</code> is 0.</p>  <p>Third query: The second 4 is a peak in the <code>[4,1,4,2,1]</code>.</p> </div>   <p><strong>Constraints:</strong></p>  <ul>  <li><code>3 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>  <li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>  <li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>  <li><code>queries[i][0] == 1</code> or <code>queries[i][0] == 2</code></li>  <li>For all <code>i</code> that:  <ul>   <li><code>queries[i][0] == 1</code>: <code>0 &lt;= queries[i][1] &lt;= queries[i][2] &lt;= nums.length - 1</code></li>   <li><code>queries[i][0] == 2</code>: <code>0 &lt;= queries[i][1] &lt;= nums.length - 1</code>, <code>1 &lt;= queries[i][2] &lt;= 10<sup>5</sup></code></li>  </ul>  </li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Create a peaks array of 0 and 1 indicating for each num in nums, whether its peak or not. Create a segtree of this peaks array. Now for query 1, we dont want no. of peaks in arr which lie in subarray [l,r] . We have to consider subarray [l,r] as new array and get peaks in this. As first and last elements cant be peaks, this is just no. of og peaks of arr which are in [l+1,r-1]. Which is just the sum of this subarray as peaks have val 1 in peaks array on which seg-tree was created. For query 2, we update nums array. Then this can affect 3 idxs in peaks array, which are i-1, i, i+1. We update the peaks value in the seg-tree for these 3 idxs after updating nums.
    </Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Peaks in Array" lines
# @param {Integer[]} nums
# @param {Integer[][]} queries
# @return {Integer[]}
class SegTree
  def initialize(n)
    @n = n # size of the source array
    @tree = Array.new(2 * n, 0)
  end

  def build(arr)
    # assuming arr is of size n
    (0...@n).each { |i| @tree[@n + i] = arr[i] } # put actual values of arr
    # build tree in descending order, so all RHS values would be initialized already
    (@n - 1).downto(1) { |i| @tree[i] = @tree[2 * i] + @tree[2 * i + 1] }
  end

  # range fn
  # [l,r) , so max value of r is n, ideally
  def query(l,r)
    l += @n; r = [@n+r, 2*@n].min
    sum = 0
    while l < r
      # odd means it is the right child of its parent,
      if l.odd?
        sum += @tree[l]; l+=1; # if l is odd, so add it and move to the right parent( go to next element and then do /2)
      end
      if r.odd?
        r-=1; sum += @tree[r] # if r is odd, as right index is excluded, so add left element, and then go to parent;
      end
      l /= 2; r /= 2
    end
    sum
  end

  # element function
  # untested as of now
  def modify(position, value)
    position += @n
    @tree[position] = value
    while position > 1
      @tree[position / 2] = @tree[position] + @tree[position ^ 1]
      position /= 2
    end
  end
end

def count_of_peaks(nums, queries)
  n = nums.size
  is_peak=->(i) {
    return false if i==0 || i==n-1
    (nums[i] > nums[i-1]) && (nums[i] > nums[i+1])
  }
  
  sg = SegTree.new(n)
  sg.build((0...n).map { |i| is_peak.call(i) ? 1:0 })

  queries.map do |q,a_1,a_2|
    if q == 1
      # peaks in subarray, not og array peaks within [l,r], which is og peaks in [l+1,r-1]
      sg.query(a_1+1, a_2)
    else
      # modify nums, and peak values for i-1, i, i+1
      nums[a_1] = a_2
      [a_1-1, a_1, a_1+1].select {|x| x.between?(0,n-1)}.each do |idx|
        sg.modify(idx, is_peak.call(idx) ? 1 : 0)
      end
      nil
    end
  end.compact

end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>