---
title: '❗️ Trapping Rain Water II'
description: '[leetcode link](https://leetcode.com/problems/trapping-rain-water-ii/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>Given an <code>m x n</code> integer matrix <code>heightMap</code> representing the height of each unit cell in a 2D elevation map, return <em>the volume of water it can trap after raining</em>.</p>   <p><strong class="example">Example 1:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2021/04/08/trap1-3d.jpg" style="width: 361px; height: 321px;" />  <strong>Input:</strong> heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]] <br/> <strong>Output:</strong> 4 <br/> <strong>Explanation:</strong> After the rain, water is trapped between the blocks. We have two small ponds 1 and 3 units trapped. The total volume of water trapped is 4.   <p><strong class="example">Example 2:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2021/04/08/trap2-3d.jpg" style="width: 401px; height: 321px;" />  <strong>Input:</strong> heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]] <br/> <strong>Output:</strong> 10    <p><strong>Constraints:</strong></p>  <ul>  <li><code>m == heightMap.length</code></li>  <li><code>n == heightMap[i].length</code></li>  <li><code>1 &lt;= m, n &lt;= 200</code></li>  <li><code>0 &lt;= heightMap[i][j] &lt;= 2 * 10<sup>4</sup></code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Do bfs with pq, processing minimum height first. Starting from minimum boundaries, and keep updating water trapped. See editorial for explanation.

Instead of pq, minHeap does not give TLE for ruby..
    </Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Trapping Rain Water II" lines
# @param {Integer[][]} height_map
# @return {Integer}
def trap_rain_water(height_map)
  m = height_map.size; n = height_map[0].size
  directions = [0,0,-1,1].zip([-1,1,0,0])
  visited = Array.new(m) { Array.new(n, false) }
  boundary_pq = Containers::MinHeap.new
  [0,m-1].each {|r| (0...n).each {|j| boundary_pq.push([height_map[r][j],r,j]); visited[r][j]=true } }
  [0,n-1].each {|c| (0...m).each {|i| 
    if !visited[i][c]
      boundary_pq.push([height_map[i][c],i,c])
      visited[i][c]=true
    end
  } }

  total_volume = 0

  until boundary_pq.empty?
    min_boundary_height,r,c = boundary_pq.pop
    directions.each do |d_row, d_col|
      n_r = r+d_row
      n_c = c+d_col

      if n_r.between?(0, m-1) && n_c.between?(0, n-1) && !visited[n_r][n_c]
        neighbor_height = height_map[n_r][n_c]
        total_volume+= (min_boundary_height-neighbor_height) if neighbor_height<min_boundary_height
        next_height = [neighbor_height, min_boundary_height].max
        boundary_pq.push([next_height, n_r, n_c])
        visited[n_r][n_c]=true
      end
    end
  end

  total_volume
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>