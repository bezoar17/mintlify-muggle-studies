---
title: "❗️ Minimum Time to Visit a Cell In a Grid"
description: '[leetcode link](https://leetcode.com/problems/minimum-time-to-visit-a-cell-in-a-grid/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given a <code>m x n</code> matrix <code>grid</code> consisting of <b>non-negative</b> integers where <code>grid[row][col]</code> represents the <strong>minimum</strong> time required to be able to visit the cell <code>(row, col)</code>, which means you can visit the cell <code>(row, col)</code> only when the time you visit it is greater than or equal to <code>grid[row][col]</code>.</p>  <p>You are standing in the <strong>top-left</strong> cell of the matrix in the <code>0<sup>th</sup></code> second, and you must move to <strong>any</strong> adjacent cell in the four directions: up, down, left, and right. Each move you make takes 1 second.</p>  <p>Return <em>the <strong>minimum</strong> time required in which you can visit the bottom-right cell of the matrix</em>. If you cannot visit the bottom-right cell, then return <code>-1</code>.</p>   <p><strong class="example">Example 1:</strong></p>  <p><img alt="" src="https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-8.png" /></p>   <strong>Input:</strong> grid = [[0,1,3,2],[5,1,2,5],[4,3,8,6]] <br/> <strong>Output:</strong> 7 <br/> <strong>Explanation:</strong> One of the paths that we can take is the following: - at t = 0, we are on the cell (0,0). - at t = 1, we move to the cell (0,1). It is possible because grid[0][1] &lt;= 1. - at t = 2, we move to the cell (1,1). It is possible because grid[1][1] &lt;= 2. - at t = 3, we move to the cell (1,2). It is possible because grid[1][2] &lt;= 3. - at t = 4, we move to the cell (1,1). It is possible because grid[1][1] &lt;= 4. - at t = 5, we move to the cell (1,2). It is possible because grid[1][2] &lt;= 5. - at t = 6, we move to the cell (1,3). It is possible because grid[1][3] &lt;= 6. - at t = 7, we move to the cell (2,3). It is possible because grid[2][3] &lt;= 7. The final time is 7. It can be shown that it is the minimum time possible.   <p><strong class="example">Example 2:</strong></p>  <p><img alt="" src="https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-9.png" style="width: 151px; height: 151px;" /></p>   <strong>Input:</strong> grid = [[0,2,4],[3,2,1],[1,0,4]] <br/> <strong>Output:</strong> -1 <br/> <strong>Explanation:</strong> There is no path from the top left to the bottom-right cell.    <p><strong>Constraints:</strong></p>  <ul>  <li><code>m == grid.length</code></li>  <li><code>n == grid[i].length</code></li>  <li><code>2 &lt;= m, n &lt;= 1000</code></li>  <li><code>4 &lt;= m * n &lt;= 10<sup>5</sup></code></li>  <li><code>0 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>  <li><code>grid[0][0] == 0</code></li> </ul>   <style type="text/css">.spoilerbutton &lbrace;display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0;  &rbrace; .spoiler &lbrace;overflow:hidden;&rbrace; .spoiler > div &lbrace;-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;&rbrace; .spoilerbutton[value="Show Message"] + .spoiler > div &lbrace;margin-top:-500%;&rbrace; .spoilerbutton[value="Hide Message"] + .spoiler &lbrace;padding:5px;&rbrace; </style> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      This is modified Dijkstra algorithm. To understand intuition and process, read and see the code.

every second 1 move needs to be made
so if you reach a cell at time t, all whose neighbor are &gt;t+1, you cant move from there
but if we are at a cell t, which has valid neighbors, we can go back and forth between these
so that unreachable neighbor nodes also become available after some time
so only case where we cant reach bottom is when starting index is &gt;0(we wont have this case as given in constraints) or starting index does not
have any neighbors, i.e no 1s

for back and forth calculation
if we are i,j at t, for neighbor which has t+x
x&lt;=1, next time is t+1
x is odd -&gt; next time is t+x
x is even -&gt; next time is t+x+1
so, next time is t + x, where x is min 1 and x if x is odd, x+1 if x is even

calculate this for neighbors, and only process the shortest time ones first, so use a pq, and keep a visited array
because we are processing cells in order by minimum time, once a cell has been processed, no further update will reduce it again
so we dont process visited nodes again
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```python3 title="Minimum Time to Visit a Cell In a Grid" lines
import heapq
from typing import List
class Solution:
    def minimumTime(self, grid: List[List[int]]) -> int:
        # Grid dimensions
        m, n = len(grid), len(grid[0])
        
        # Possible movement directions
        directions = [(1,0), (0,1), (-1,0), (0,-1)]
        
        # Check if starting point is blocked
        def neighbors_in_range(x: int, y: int) -> List[tuple]:
            return [
                (x+dx, y+dy) for dx, dy in directions 
                if 0 <= x+dx < m and 0 <= y+dy < n
            ]
        
        # If all neighbors from start are blocked by values > 1
        if all(grid[x][y] > 1 for x, y in neighbors_in_range(0, 0)):
            return -1
        
        # Priority queue to manage traversal
        # Using heapq with (time, row, col) to simulate min-heap
        pq = [(0, 0, 0)]
        visited = set()
        
        while pq:
            t, i, j = heapq.heappop(pq)
            
            # Reached bottom-right corner
            if i == m-1 and j == n-1:
                return t
            
            # Skip if already visited
            if (i, j) in visited:
                continue
            visited.add((i, j))
            
            # Check all neighboring cells
            for n_i, n_j in neighbors_in_range(i, j):
                if (n_i, n_j) in visited:
                    continue
                
                # Calculate time to move to next cell
                time_difference = grid[n_i][n_j] - t
                
                # Adjust waiting time based on time difference
                if time_difference <= 0:
                    # Can move immediately
                    next_time = t + 1
                elif time_difference % 2 == 0:
                    # Even difference requires additional wait
                    next_time = t + time_difference + 1
                else:
                    # Odd difference can move at that time
                    next_time = t + time_difference
                
                # Push to priority queue
                heapq.heappush(pq, (next_time, n_i, n_j))
        
        return -1
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>