---
title: '❗️ Find the Number of Subarrays Where Boundary Elements Are Maximum'
description: '[leetcode link](https://leetcode.com/problems/find-the-number-of-subarrays-where-boundary-elements-are-maximum/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given an array of <strong>positive</strong> integers <code>nums</code>.</p>  <p>Return the number of <span data-keyword="subarray-nonempty">subarrays</span> of <code>nums</code>, where the <strong>first</strong> and the <strong>last</strong> elements of the subarray are <em>equal</em> to the <strong>largest</strong> element in the subarray.</p>   <p><strong class="example">Example 1:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">nums = [1,4,3,3,2]</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">6</span></p>  <p><br/> <strong>Explanation:</strong></p>  <p>There are 6 subarrays which have the first and the last elements equal to the largest element of the subarray:</p>  <ul>  <li>subarray <code>[<strong><u>1</u></strong>,4,3,3,2]</code>, with its largest element 1. The first element is 1 and the last element is also 1.</li>  <li>subarray <code>[1,<u><strong>4</strong></u>,3,3,2]</code>, with its largest element 4. The first element is 4 and the last element is also 4.</li>  <li>subarray <code>[1,4,<u><strong>3</strong></u>,3,2]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>  <li>subarray <code>[1,4,3,<u><strong>3</strong></u>,2]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>  <li>subarray <code>[1,4,3,3,<u><strong>2</strong></u>]</code>, with its largest element 2. The first element is 2 and the last element is also 2.</li>  <li>subarray <code>[1,4,<u><strong>3,3</strong></u>,2]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li> </ul>  <p>Hence, we return 6.</p> </div>  <p><strong class="example">Example 2:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">nums = [3,3,3]</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">6</span></p>  <p><br/> <strong>Explanation:</strong></p>  <p>There are 6 subarrays which have the first and the last elements equal to the largest element of the subarray:</p>  <ul>  <li>subarray <code>[<u><strong>3</strong></u>,3,3]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>  <li>subarray <code>[3,<strong><u>3</u></strong>,3]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>  <li>subarray <code>[3,3,<u><strong>3</strong></u>]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>  <li>subarray <code>[<strong><u>3,3</u></strong>,3]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>  <li>subarray <code>[3,<u><strong>3,3</strong></u>]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>  <li>subarray <code>[<u><strong>3,3,3</strong></u>]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li> </ul>  <p>Hence, we return 6.</p> </div>  <p><strong class="example">Example 3:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">nums = [1]</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">1</span></p>  <p><br/> <strong>Explanation:</strong></p>  <p>There is a single subarray of <code>nums</code> which is <code>[<strong><u>1</u></strong>]</code>, with its largest element 1. The first element is 1 and the last element is also 1.</p>  <p>Hence, we return 1.</p> </div>   <p><strong>Constraints:</strong></p>  <ul>  <li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>  <li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      subarray count can only be updated when a number repeats. If there were no repeats, ans would be n.
when a number repeats, at an index R, R can be the end of a valid subarray, for all previous indexes L_i, such that there are no elements greater than num at R. If there are x such indices L_i, with first such index as L. Then x subarrays is added to the count, all these x can end at R.

So, from going left to right, if we maintain prev_gr_idx for num_i. And maintain leftmost valid_idx for num_i. And valid_count. Then we can calculate this in one go. 
If we see a repeat of num_i, if prev_gr_idx is less than leftmost_valid_idx, then we can add valid_count to the answer. If prev_gr_idx is greater than leftmost_valid_idx, then leftmost_valid_idx should be updated to idx, and count will be reset, because no earlier index can be the start of subarray where num_i is max.

Also, min value of subarray_count is n. 
    </Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Find the Number of Subarrays Where Boundary Elements Are Maximum" lines
# @param {Integer[]} nums
# @return {Integer}
def number_of_subarrays(nums)
  prev_gr_idx = g_idx(nums, -1)
  n = nums.size
  sub_array_count = n
  start_idx = {}
  count_from_start = Hash.new(0)

  # calculate assuming idx is R of subarray
  (0...n).each do |idx|
    if start_idx.has_key?(nums[idx]) && prev_gr_idx[idx] < start_idx[nums[idx]] 
      # increment subarray_count, count_from_start indexes will be left for idx as R
      sub_array_count += count_from_start[nums[idx]]
      count_from_start[nums[idx]] += 1 # update count
    else # reset state
      start_idx[nums[idx]] = idx
      count_from_start[nums[idx]] = 1
    end
  end
  sub_array_count
end


# remove everything from stack that is not smaller than current number
def discard?(top,num) = top<=num;

def g_idx(nums, direction)
  n = nums.size
  calculate_previous = direction == -1;
  default, index_range = calculate_previous ? [-1, (0...n)] : [n, (n-1).downto(0)]

  result = Array.new(nums.size, default)
  stack = [] # stores only the index of element, not [element, idx]

  index_range.each do |idx|
    stack.pop while !stack.empty? && discard?(nums[stack.last], nums[idx])
    result[idx] = stack.last unless stack.empty?
    stack << idx
  end
  result
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>