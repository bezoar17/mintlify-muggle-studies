---
title: "❗️ Minimum Cost Walk in Weighted Graph"
description: '[leetcode link](https://leetcode.com/problems/minimum-cost-walk-in-weighted-graph/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>There is an undirected weighted graph with <code>n</code> vertices labeled from <code>0</code> to <code>n - 1</code>.</p>  <p>You are given the integer <code>n</code> and an array <code>edges</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, w<sub>i</sub>]</code> indicates that there is an edge between vertices <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> with a weight of <code>w<sub>i</sub></code>.</p>  <p>A walk on a graph is a sequence of vertices and edges. The walk starts and ends with a vertex, and each edge connects the vertex that comes before it and the vertex that comes after it. It&#39;s important to note that a walk may visit the same edge or vertex more than once.</p>  <p>The <strong>cost</strong> of a walk starting at node <code>u</code> and ending at node <code>v</code> is defined as the bitwise <code>AND</code> of the weights of the edges traversed during the walk. In other words, if the sequence of edge weights encountered during the walk is <code>w<sub>0</sub>, w<sub>1</sub>, w<sub>2</sub>, ..., w<sub>k</sub></code>, then the cost is calculated as <code>w<sub>0</sub> &amp; w<sub>1</sub> &amp; w<sub>2</sub> &amp; ... &amp; w<sub>k</sub></code>, where <code>&amp;</code> denotes the bitwise <code>AND</code> operator.</p>  <p>You are also given a 2D array <code>query</code>, where <code>query[i] = [s<sub>i</sub>, t<sub>i</sub>]</code>. For each query, you need to find the minimum cost of the walk starting at vertex <code>s<sub>i</sub></code> and ending at vertex <code>t<sub>i</sub></code>. If there exists no such walk, the answer is <code>-1</code>.</p>  <p>Return <em>the array </em><code>answer</code><em>, where </em><code>answer[i]</code><em> denotes the <strong>minimum</strong> cost of a walk for query </em><code>i</code>.</p>   <p><strong class="example">Example 1:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">n = 5, edges = [[0,1,7],[1,3,7],[1,2,1]], query = [[0,3],[3,4]]</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">[1,-1]</span></p>  <p><br/> <strong>Explanation:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2024/01/31/q4_example1-1.png" style="padding: 10px; background: rgb(255, 255, 255); border-radius: 0.5rem; width: 351px; height: 141px;" /> <p>To achieve the cost of 1 in the first query, we need to move on the following edges: <code>0-&gt;1</code> (weight 7), <code>1-&gt;2</code> (weight 1), <code>2-&gt;1</code> (weight 1), <code>1-&gt;3</code> (weight 7).</p>  <p>In the second query, there is no walk between nodes 3 and 4, so the answer is -1.</p>  <p><strong class="example">Example 2:</strong></p> </div>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,2,7],[0,1,15],[1,2,6],[1,2,1]], query = [[1,2]]</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">[0]</span></p>  <p><br/> <strong>Explanation:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2024/01/31/q4_example2e.png" style="padding: 10px; background: rgb(255, 255, 255); border-radius: 0.5rem; width: 211px; height: 181px;" /> <p>To achieve the cost of 0 in the first query, we need to move on the following edges: <code>1-&gt;2</code> (weight 1), <code>2-&gt;1</code> (weight 6), <code>1-&gt;2</code> (weight 1).</p> </div>   <p><strong>Constraints:</strong></p>  <ul>  <li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>  <li><code>0 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>  <li><code>edges[i].length == 3</code></li>  <li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n - 1</code></li>  <li><code>u<sub>i</sub> != v<sub>i</sub></code></li>  <li><code>0 &lt;= w<sub>i</sub> &lt;= 10<sup>5</sup></code></li>  <li><code>1 &lt;= query.length &lt;= 10<sup>5</sup></code></li>  <li><code>query[i].length == 2</code></li>  <li><code>0 &lt;= s<sub>i</sub>, t<sub>i</sub> &lt;= n - 1</code></li>  <li><code>s<sub>i</sub> !=&nbsp;t<sub>i</sub></code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      https://leetcode.com/problems/minimum-cost-walk-in-weighted-graph/solutions/6339840/ruby-100-explained-with-intuition-by-bez-9cge
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Minimum Cost Walk in Weighted Graph" lines
# @param {Integer} n
# @param {Integer[][]} edges
# @param {Integer[][]} query
# @return {Integer[]}
class UnionFind
  attr_accessor :nodes, :sizes
  attr_reader :max_set_size, :component_AND_val

  def initialize(node_keys=[])
    @nodes = {}
    @sizes = {}
    @component_AND_val = {}
    node_keys.each { |i| root(i) }
  end

  # this will create a node key if it doesnt exist
  def root(i)
    nodes[i] ||= i; sizes[i] ||= 1;  @component_AND_val[i] ||= (2**18-1)  # create node if it doesnt exist

    while nodes[i] != i
      nodes[i] = nodes[nodes[i]] # path compression
      i = nodes[i]
    end
    i
  end

  def size_for(i)
    sizes[root(i)]
  end

  def union(i, j, w)
    root_of_i = root(i)
    root_of_j = root(j)

    return component_AND_val[root_of_i]&=w if root_of_i == root_of_j

    if sizes[root_of_j] > sizes[root_of_i]
      nodes[root_of_i] = root_of_j
      sizes[root_of_j] += sizes[root_of_i]
      component_AND_val[root_of_j] = (component_AND_val[root_of_j] & component_AND_val[root_of_i] & w)
    else
      nodes[root_of_j] = root_of_i
      sizes[root_of_i] += sizes[root_of_j]
      component_AND_val[root_of_i] = (component_AND_val[root_of_j] & component_AND_val[root_of_i] & w)
    end
  end
end

def minimum_cost(n, edges, query)
  # modify union find to store edge & value, for all edges, so keep updating component_AND_val[root]&=w
  uf = UnionFind.new((0...n).to_a)
  edges.each {|x,y,w| uf.union(x,y,w) }
  query.map { |u,v| (uf.root(u) != uf.root(v) )? -1 : uf.component_AND_val[uf.root(u)] }
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>