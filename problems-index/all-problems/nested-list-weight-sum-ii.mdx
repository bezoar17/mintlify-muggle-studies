---
title: "ðŸ§€ Nested List Weight Sum II"
description: '[leetcode link](https://leetcode.com/problems/nested-list-weight-sum-ii/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given a nested list of integers <code>nestedList</code>. Each element is either an integer or a list whose elements may also be integers or other lists.</p>  <p>The <strong>depth</strong> of an integer is the number of lists that it is inside of. For example, the nested list <code>[1,[2,2],[[3],2],1]</code> has each integer&#39;s value set to its <strong>depth</strong>. Let <code>maxDepth</code> be the <strong>maximum depth</strong> of any integer.</p>  <p>The <strong>weight</strong> of an integer is <code>maxDepth - (the depth of the integer) + 1</code>.</p>  <p>Return <em>the sum of each integer in </em><code>nestedList</code><em> multiplied by its <strong>weight</strong></em>.</p>   <p><strong class="example">Example 1:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2021/03/27/nestedlistweightsumiiex1.png" style="width: 426px; height: 181px;" />  <strong>Input:</strong> nestedList = [[1,1],2,[1,1]] <br/> <strong>Output:</strong> 8 <br/> <strong>Explanation:</strong> Four 1&#39;s with a weight of 1, one 2 with a weight of 2. 1*1 + 1*1 + 2*2 + 1*1 + 1*1 = 8   <p><strong class="example">Example 2:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2021/03/27/nestedlistweightsumiiex2.png" style="width: 349px; height: 192px;" />  <strong>Input:</strong> nestedList = [1,[4,[6]]] <br/> <strong>Output:</strong> 17 <br/> <strong>Explanation:</strong> One 1 at depth 3, one 4 at depth 2, and one 6 at depth 1. 1*3 + 4*2 + 6*1 = 17    <p><strong>Constraints:</strong></p>  <ul>  <li><code>1 &lt;= nestedList.length &lt;= 50</code></li>  <li>The values of the integers in the nested list is in the range <code>[-100, 100]</code>.</li>  <li>The maximum <strong>depth</strong> of any integer is less than or equal to <code>50</code>.</li>  <li>There are no empty lists.</li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Weight = maxDepth + 1 - (the depth of the integer)

Each no. is multiplied by its weight, in weight first part is static for all elements, last part, i.e depth of a no. is variable for different no.s.

So for final value, for the static part, we are just calculating the sum of all nums, and multiplying it by maxDepth+1.

For the variable part, we are getting sum of num* depth, for all nums.

In one go, we can calculate  direct sum, depth-sum and max-depth all things. Then use it in the formula.
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Nested List Weight Sum II" lines
# This is the interface that allows for creating nested lists.
# You should not implement it, or speculate about its implementation
#
#class NestedInteger
#    def is_integer()
#        """
#        Return true if this NestedInteger holds a single integer, rather than a nested list.
#        @return {Boolean}
#        """
#
#    def get_integer()
#        """
#        Return the single integer that this NestedInteger holds, if it holds a single integer
#        Return nil if this NestedInteger holds a nested list
#        @return {Integer}
#        """
#
#    def set_integer(value)
#        """
#        Set this NestedInteger to hold a single integer equal to value.
#        @return {Void}
#        """
#
#    def add(elem)
#        """
#        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.
#        @return {Void}
#        """
#
#    def get_list()
#        """
#        Return the nested list that this NestedInteger holds, if it holds a nested list
#        Return nil if this NestedInteger holds a single integer
#        @return {NestedInteger[]}
#        """

# @param {NestedInteger[]} nested_list
# @return {Integer}
def depth_sum_inverse(nested_list)
  max_depth = depth_sum = flat_sum = 0

  recurse=->(ni, d) {
    max_depth = [max_depth, d].max
    
    unless ni.is_integer
      ni.get_list().each { |elem| recurse.call(elem, d+1) }
    else
      flat_sum += ni.get_integer()
      depth_sum += ni.get_integer() * d
      return
    end
  }
  
  nested_list.each { |elem| recurse.call(elem, 1) }
  
  (max_depth+1) * flat_sum - depth_sum
end

```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>