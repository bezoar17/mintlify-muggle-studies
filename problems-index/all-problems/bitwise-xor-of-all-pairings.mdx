---
title: 'ðŸ§€ Bitwise XOR of All Pairings'
description: '[leetcode link](https://leetcode.com/problems/bitwise-xor-of-all-pairings/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given two <strong>0-indexed</strong> arrays, <code>nums1</code> and <code>nums2</code>, consisting of non-negative integers. Let there be another array, <code>nums3</code>, which contains the bitwise XOR of <strong>all pairings</strong> of integers between <code>nums1</code> and <code>nums2</code> (every integer in <code>nums1</code> is paired with every integer in <code>nums2</code> <strong>exactly once</strong>).</p>  <p>Return<em> the <strong>bitwise XOR</strong> of all integers in </em><code>nums3</code>.</p>   <p><strong class="example">Example 1:</strong></p>   <strong>Input:</strong> nums1 = [2,1,3], nums2 = [10,2,5,0] <br/> <strong>Output:</strong> 13 <br/> <strong>Explanation:</strong> A possible nums3 array is [8,0,7,2,11,3,4,1,9,1,6,3]. The bitwise XOR of all these numbers is 13, so we return 13.   <p><strong class="example">Example 2:</strong></p>   <strong>Input:</strong> nums1 = [1,2], nums2 = [3,4] <br/> <strong>Output:</strong> 0 <br/> <strong>Explanation:</strong> All possible pairs of bitwise XORs are nums1[0] ^ nums2[0], nums1[0] ^ nums2[1], nums1[1] ^ nums2[0], and nums1[1] ^ nums2[1]. Thus, one possible nums3 array is [2,5,1,6]. 2 ^ 5 ^ 1 ^ 6 = 0, so we return 0.    <p><strong>Constraints:</strong></p>  <ul>  <li><code>1 &lt;= nums1.length, nums2.length &lt;= 10<sup>5</sup></code></li>  <li><code>0 &lt;= nums1[i], nums2[j] &lt;= 10<sup>9</sup></code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Suppose nums1 is [a,b] and nums2 is [c,d,e]. In the output, we will have a^c, a^d, a^e, b^c,b^d, b^e. And all these values will be xor'd together. So, the final xor will have a and b will occur 3 times, and c,d,e will occur 2 times each. Each number occurs n times, where n is size of the other array. Maintain a hash for all distinct numbers in nums1 and nums2 to get count of appearance in final xor. For a number, if it appears even times, it cancels out in the resulting xor, so just xor the numbers occuring odd times.
    </Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Bitwise XOR of All Pairings" lines
# @param {Integer[]} nums1
# @param {Integer[]} nums2
# @return {Integer}
def xor_all_nums(nums1, nums2)
  n1 = nums1.size; n2 = nums2.size
  count_h = Hash.new(0)
  nums1.each { |x| count_h[x]+=n2 }
  nums2.each { |x| count_h[x]+=n1 }

  count_h.select {|k,v| v.odd?}.map(&:first).reduce(0) {|res, x| res^x }
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>