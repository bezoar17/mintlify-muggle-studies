---
title: "❗️ Sum of Beautiful Subsequences"
description: '[leetcode link](https://leetcode.com/problems/sum-of-beautiful-subsequences/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given an integer array <code>nums</code> of length <code>n</code>.</p>  <p>For every <strong>positive</strong> integer <code>g</code>, we define the <strong>beauty</strong> of <code>g</code> as the <strong>product</strong> of <code>g</code> and the number of <strong>strictly increasing</strong> <strong><span data-keyword="subsequence-array-nonempty">subsequences</span></strong> of <code>nums</code> whose greatest common divisor (GCD) is exactly <code>g</code>.</p>  <p>Return the <strong>sum</strong> of <strong>beauty</strong> values for all positive integers <code>g</code>.</p>  <p>Since the answer could be very large, return it modulo <code>10<sup>9</sup> + 7</code>.</p>   <p><strong class="example">Example 1:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">nums = [1,2,3]</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">10</span></p>  <p><br/> <strong>Explanation:</strong></p>  <p>All strictly increasing subsequences and their GCDs are:</p>  <table style="border: 1px solid black;">  <thead>   <tr>    <th style="border: 1px solid black;">Subsequence</th>    <th style="border: 1px solid black;">GCD</th>   </tr>  </thead>  <tbody>   <tr>    <td style="border: 1px solid black;">[1]</td>    <td style="border: 1px solid black;">1</td>   </tr>   <tr>    <td style="border: 1px solid black;">[2]</td>    <td style="border: 1px solid black;">2</td>   </tr>   <tr>    <td style="border: 1px solid black;">[3]</td>    <td style="border: 1px solid black;">3</td>   </tr>   <tr>    <td style="border: 1px solid black;">[1,2]</td>    <td style="border: 1px solid black;">1</td>   </tr>   <tr>    <td style="border: 1px solid black;">[1,3]</td>    <td style="border: 1px solid black;">1</td>   </tr>   <tr>    <td style="border: 1px solid black;">[2,3]</td>    <td style="border: 1px solid black;">1</td>   </tr>   <tr>    <td style="border: 1px solid black;">[1,2,3]</td>    <td style="border: 1px solid black;">1</td>   </tr>  </tbody> </table>  <p>Calculating beauty for each GCD:</p>  <table style="border: 1px solid black;">  <thead>   <tr>    <th style="border: 1px solid black;">GCD</th>    <th style="border: 1px solid black;">Count of subsequences</th>    <th style="border: 1px solid black;">Beauty (GCD &times; Count)</th>   </tr>  </thead>  <tbody>   <tr>    <td style="border: 1px solid black;">1</td>    <td style="border: 1px solid black;">5</td>    <td style="border: 1px solid black;">1 &times; 5 = 5</td>   </tr>   <tr>    <td style="border: 1px solid black;">2</td>    <td style="border: 1px solid black;">1</td>    <td style="border: 1px solid black;">2 &times; 1 = 2</td>   </tr>   <tr>    <td style="border: 1px solid black;">3</td>    <td style="border: 1px solid black;">1</td>    <td style="border: 1px solid black;">3 &times; 1 = 3</td>   </tr>  </tbody> </table>  <p>Total beauty is <code>5 + 2 + 3 = 10</code>.</p> </div>  <p><strong class="example">Example 2:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">nums = [4,6]</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">12</span></p>  <p><br/> <strong>Explanation:</strong></p>  <p>All strictly increasing subsequences and their GCDs are:</p>  <table style="border: 1px solid black;">  <thead>   <tr>    <th style="border: 1px solid black;">Subsequence</th>    <th style="border: 1px solid black;">GCD</th>   </tr>  </thead>  <tbody>   <tr>    <td style="border: 1px solid black;">[4]</td>    <td style="border: 1px solid black;">4</td>   </tr>   <tr>    <td style="border: 1px solid black;">[6]</td>    <td style="border: 1px solid black;">6</td>   </tr>   <tr>    <td style="border: 1px solid black;">[4,6]</td>    <td style="border: 1px solid black;">2</td>   </tr>  </tbody> </table>  <p>Calculating beauty for each GCD:</p>  <table style="border: 1px solid black;">  <thead>   <tr>    <th style="border: 1px solid black;">GCD</th>    <th style="border: 1px solid black;">Count of subsequences</th>    <th style="border: 1px solid black;">Beauty (GCD &times; Count)</th>   </tr>  </thead>  <tbody>   <tr>    <td style="border: 1px solid black;">2</td>    <td style="border: 1px solid black;">1</td>    <td style="border: 1px solid black;">2 &times; 1 = 2</td>   </tr>   <tr>    <td style="border: 1px solid black;">4</td>    <td style="border: 1px solid black;">1</td>    <td style="border: 1px solid black;">4 &times; 1 = 4</td>   </tr>   <tr>    <td style="border: 1px solid black;">6</td>    <td style="border: 1px solid black;">1</td>    <td style="border: 1px solid black;">6 &times; 1 = 6</td>   </tr>  </tbody> </table>  <p>Total beauty is <code>2 + 4 + 6 = 12</code>.</p> </div>   <p><strong>Constraints:</strong></p>  <ul>  <li><code>1 &lt;= n == nums.length &lt;= 10<sup>4</sup></code></li>  <li><code>1 &lt;= nums[i] &lt;= 7 * 10<sup>4</sup></code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Fenwick Tree - Extreme LIS optimization, look at ruby code for understanding and implementation, ruby gives tle though, implemented in C#

Consider the simple problem of given an array nums, find the total no. of strictly sub-sequences. Similar to the LIS problem, solution to this problem can also be optimized from n^2 to nlogn.  https://cp-algorithms.com/dynamic_programming/longest_increasing_subsequence.html#solution-in-on-log-n-with-data-structures. Getting log n is simply due to getting the prefix sum in logn using a Fenwick tree which is optimized for prefix-sums. But assuming you can find the total no. of strictly sub-sequences in a given array in nlogn. 

(Actually it is nlogk, where k is no. of unique values, more detail on this below)

The problem becomes simple, assume you have to find the result for a given g. Then first of all, take all nums which are multiples of g. This is your multiples array M(g). Lets call total no. of strictly sub-sequences of an arr as f(arr).

Now, f(M(g)) contains total strictly increasing sub-sequences of all multiples of g. i.e, including multiples of 2g, 3g, 4g etc. (The actual multiples array for these is a sub-sequence of original multiples array).

Now, let G(g) be the number of strictly increasing subsequences with gcd exactly g. 
Then by subtracting multiples, G can be found from F:
F(M(g))=∑ G(kg), k &gt;=1

G(g)=F(g)−∑G(kd), k&gt;=2
The answer to original problem is ∑g∗G(g).

Basically from f(M(g)), we are removing G(2g), G(3g) and so on, to get G(g). We are removing all sub-sequences which are also part of 2g being their common divisor, i.e when 2g is picked, its multiples array would be a sub-sequence of the original multiples array, we have to remove f(M(2g)) from f(M(g)), as for these sub-sequences 2g is the gcd, not g. 


Now, coming back to the original problem of given an array nums, find the total no. of strictly sub-sequences. First of all, why nlogk and not nlogn. If there are lots of duplicates or no.s are very far apart, we have to map all actual nums to virtual ranks, as we are only interested in sequence being increasing, and not actual values. We can take any input array and map it to a virtual rank. For e.g, following transformations to ranks will have same result in calculation of f(arr) 
[10, 20, 30, 40] -&gt; [1,2,3,4] 
[10, 20, 30, 20, 40] -&gt; [1,2,3,2,4]  In fenwick tree, we will only store rank-wise results, when many duplicates are present, we'll see lower no. of actual ranks than nums.
[10, 20, 30, 20, 40000] -&gt; [1,2,3,2,4] When actual num is very large, instead of raw nums, we can store ranks, to reduce range in fenwick tree.

Now, why fenwick tree ? Because it will efficiently solve 1 part of the query we'll need.

Lets start with the n^2 solution. Given a ranked nums array, [1,2,3,2,4,3,1]. If we go from left to right, and for each idx, sum the total sub-sequences ending at that idx, we will have our answer.

We will track total sub-sequences for each rank till i-1. Assuming it is in an array sb_count(1....r), counts for each rank till i-1. Now when we process index i, assuming it has a rank r. Then sb_count of r will increase by no. of sub-sequences ending at i. No. of sub-sequences ending at i is sum of 1 + sb_count for all ranks &lt; r. The 1 is for the new sub-sequence which starts and ends at i. And the next term is extending all existing sub-sequences, which is basically all subsequences for each rank which is less than r, can be extending with this index.

Formally,  after processing i, sb_count[r]+= 1 + sb_count[1...r].sum. And then the next idx with a different r has to be processed. Without any optimization, we process n idxs, from the array, and each time, we calculate sum of 1..r, which can be at max k, so time complexity is n* k.

But, if we look at the update which happens here, sb_count[r]+= 1 + sb_count[1...r].sum.
In RHS, we are basically calculating prefix_sum till r-1. And then updating r. So, for the next iteration, the prefix sum value might change. If we were using a seg_tree, this would be always querying sum of (0,r-1), and updating r. But Fenwick trees can also be used which are specialized for prefix_sums, and store lesser space. Using a fenwick tree fo k elements would make the operation log k. Hence total time complexity becomes nlogK.

Now, for the original problem original multiples is our array for which this has to be calculated, with each multiple of g, going from g to 2g and so on, the size of multiples will decrease and hence the nlogK metric.
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```csharp title="Sum of Beautiful Subsequences" lines
using System;
using System.Collections.Generic;
using System.Linq;

public class FenwickTree {
  private long[] tree;
  
  public FenwickTree(int size) {
    tree = new long[size + 1];
  }
  
  public void Update(int idx, long delta) {
    for (idx++; idx < tree.Length; idx += idx & -idx)
      tree[idx] += delta;
  }
  
  public long Sum(int idx) {
    long result = 0;
    for (idx++; idx > 0; idx -= idx & -idx)
      result += tree[idx];
    return result;
  }
}

public class Solution {
  const int MOD = 1000000007;
  public Dictionary<int, List<int>> BuildDivisorMultiples(int[] nums) {
    var divisors = new Dictionary<int, List<int>>();
    
    foreach (var num in nums) {
      for (int i = 1; i * i <= num; i++) {
        if (num % i == 0) {
          (divisors.TryGetValue(i, out var list1) ? list1 : divisors[i] = new()).Add(num);
          if (i != num / i) (divisors.TryGetValue(num / i, out var list2) ? list2 : divisors[num / i] = new()).Add(num);
        }
      }
    }
    
    return divisors;
  }

  public long CountIncreasingSubsequences(int[] nums) {
    if (nums.Length < 2) return nums.Length;
    
    var ranks = nums.Distinct().OrderBy(x => x).Select((v, i) => new { v, i }).ToDictionary(x => x.v, x => x.i);
    var fen = new FenwickTree(ranks.Count);
    
    foreach (var num in nums) {
      int rank = ranks[num];
      long count = 1 + fen.Sum(rank - 1);
      fen.Update(rank, count%MOD);
    }
    
    return fen.Sum(ranks.Count - 1);
  }
  
  public int TotalBeauty(int[] nums) {
      int maxVal = nums.Max();
      long[] f = new long[maxVal + 1];
      long[] g = new long[maxVal + 1];
      
      var multiples = BuildDivisorMultiples(nums);
      
      for (int d = 1; d <= maxVal; d++) f[d] = multiples.ContainsKey(d) ? CountIncreasingSubsequences(multiples[d].ToArray()) : 0;

      for (int d = maxVal; d >= 1; d--) { 
        g[d] = f[d];
        for (int multi = 2 * d; multi <= maxVal; multi += d) g[d] = (g[d] - g[multi]);
        g[d] %= MOD;
      }
      
      long result = 0;
      for (int i = 1; i <= maxVal; i++) { result = (result + (long)i * g[i]) % MOD; }
      
      return (int) result% MOD;
  }
}
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>