---
title: "❗️ Number of Ways to Wear Different Hats to Each Other"
description: '[leetcode link](https://leetcode.com/problems/number-of-ways-to-wear-different-hats-to-each-other/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>There are <code>n</code> people and <code>40</code> types of hats labeled from <code>1</code> to <code>40</code>.</p>  <p>Given a 2D integer array <code>hats</code>, where <code>hats[i]</code> is a list of all hats preferred by the <code>i<sup>th</sup></code> person.</p>  <p>Return the number of ways that <code>n</code> people can wear <strong>different</strong> hats from each other.</p>  <p>Since the answer may be too large, return it modulo <code>10<sup>9</sup> + 7</code>.</p>   <p><strong class="example">Example 1:</strong></p>   <strong>Input:</strong> hats = [[3,4],[4,5],[5]] <br/> <strong>Output:</strong> 1 <br/> <strong>Explanation:</strong> There is only one way to choose hats given the conditions.  First person choose hat 3, Second person choose hat 4 and last one hat 5.   <p><strong class="example">Example 2:</strong></p>   <strong>Input:</strong> hats = [[3,5,1],[3,5]] <br/> <strong>Output:</strong> 4 <br/> <strong>Explanation:</strong> There are 4 ways to choose hats: (3,5), (5,3), (1,3) and (1,5)   <p><strong class="example">Example 3:</strong></p>   <strong>Input:</strong> hats = [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]] <br/> <strong>Output:</strong> 24 <br/> <strong>Explanation:</strong> Each person can choose hats labeled from 1 to 4. Number of Permutations of (1,2,3,4) = 24.    <p><strong>Constraints:</strong></p>  <ul>  <li><code>n == hats.length</code></li>  <li><code>1 &lt;= n &lt;= 10</code></li>  <li><code>1 &lt;= hats[i].length &lt;= 40</code></li>  <li><code>1 &lt;= hats[i][j] &lt;= 40</code></li>  <li><code>hats[i]</code> contains a list of <strong>unique</strong> integers.</li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Sum over subset.

mask should represent people with hats already assigned. So by the end we want 10 1s, this is better than representing hats with a mask as hat count is 40. 

Now, for each hat, we either assign it to someone valid(people who are ok with this hat and dont have a hat), or skip it.

for ith hat, and a particular mask, skip + choose to assign the mask.
dp[i][mask] = dp[i-1][mask] + Sum of dp[i-1][ mask with person bit unset -&gt; person gets ith hat] for all valid persons, i.e people who want this hat and get this hat in this iteration, and don't have it in their last iteration.

Since dp(i) only depends on i-1, we can only keep states as single array of all masks. For the first hat, mask 0 and masks 1&lt;&lt; persons who have first hat have value = 1, i.e 1 way to get to those masks with first hat. Then, for the next hat, we process all masks(states), and for all persons who can wear this hat, and did not have it, we update the next state by giving them this hat.
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Number of Ways to Wear Different Hats to Each Other" lines
# @param {Integer[][]} hats
# @return {Integer}
def number_ways(hats)
  big_mod = 10**9 + 7
  hat_count = 40
  n = hats.size
  dp = Array.new(1<<n, 0)

  hat_to_people = Hash.new {|h,k| h[k]=[]}
  (0...n).each { |person| hats[person].each {|h| hat_to_people[h]<<person } }

  # base case, only 1 way for mask 0 or 1<<person
  ([0] + hat_to_people[1].map{|p| 1<<p}).each { |mask| dp[mask] = 1 }

  (2..hat_count).each do |h|
    dp_new = dp.dup # first case dp[i] = dp[i-1] for all masks, when this hat is skipped

    # for each hat, process all masks, where person can but did not have this hat, and add it
    hat_to_people[h].each do |person|
      (0...(1<<n)).select {|last_mask_p| last_mask_p & (1<<person)==0 }.each do |last_mask_p|
        dp_new[last_mask_p | (1<<person)] += dp[last_mask_p]
        dp_new[last_mask_p | (1<<person)]%= big_mod
      end
    end

    dp = dp_new
  end

  dp[(1<<n)-1] % big_mod  
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>