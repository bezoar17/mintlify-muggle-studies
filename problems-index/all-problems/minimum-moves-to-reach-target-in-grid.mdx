---
title: '❗️ Minimum Moves to Reach Target in Grid'
description: '[leetcode link](https://leetcode.com/problems/minimum-moves-to-reach-target-in-grid/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given four integers <code>sx</code>, <code>sy</code>, <code>tx</code>, and <code>ty</code>, representing two points <code>(sx, sy)</code> and <code>(tx, ty)</code> on an infinitely large 2D grid.</p>  <p>You start at <code>(sx, sy)</code>.</p>  <p>At any point <code>(x, y)</code>, define <code>m = max(x, y)</code>. You can either:</p>  <ul>  <li>Move to <code>(x + m, y)</code>, or</li>  <li>Move to <code>(x, y + m)</code>.</li> </ul>  <p>Return the <strong>minimum</strong> number of moves required to reach <code>(tx, ty)</code>. If it is impossible to reach the target, return -1.</p>   <p><strong class="example">Example 1:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">sx = 1, sy = 2, tx = 5, ty = 4</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">2</span></p>  <p><br/> <strong>Explanation:</strong></p>  <p>The optimal path is:</p>  <ul>  <li>Move 1: <code>max(1, 2) = 2</code>. Increase the y-coordinate by 2, moving from <code>(1, 2)</code> to <code>(1, 2 + 2) = (1, 4)</code>.</li>  <li>Move 2: <code>max(1, 4) = 4</code>. Increase the x-coordinate by 4, moving from <code>(1, 4)</code> to <code>(1 + 4, 4) = (5, 4)</code>.</li> </ul>  <p>Thus, the minimum number of moves to reach <code>(5, 4)</code> is 2.</p> </div>  <p><strong class="example">Example 2:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">sx = 0, sy = 1, tx = 2, ty = 3</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">3</span></p>  <p><br/> <strong>Explanation:</strong></p>  <p>The optimal path is:</p>  <ul>  <li>Move 1: <code>max(0, 1) = 1</code>. Increase the x-coordinate by 1, moving from <code>(0, 1)</code> to <code>(0 + 1, 1) = (1, 1)</code>.</li>  <li>Move 2: <code>max(1, 1) = 1</code>. Increase the x-coordinate by 1, moving from <code>(1, 1)</code> to <code>(1 + 1, 1) = (2, 1)</code>.</li>  <li>Move 3: <code>max(2, 1) = 2</code>. Increase the y-coordinate by 2, moving from <code>(2, 1)</code> to <code>(2, 1 + 2) = (2, 3)</code>.</li> </ul>  <p>Thus, the minimum number of moves to reach <code>(2, 3)</code> is 3.</p> </div>  <p><strong class="example">Example 3:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">sx = 1, sy = 1, tx = 2, ty = 2</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">-1</span></p>  <p><br/> <strong>Explanation:</strong></p>  <ul>  <li>It is impossible to reach <code>(2, 2)</code> from <code>(1, 1)</code> using the allowed moves. Thus, the answer is -1.</li> </ul> </div>   <p><strong>Constraints:</strong></p>  <ul>  <li><code>0 &lt;= sx &lt;= tx &lt;= 10<sup>9</sup></code></li>  <li><code>0 &lt;= sy &lt;= ty &lt;= 10<sup>9</sup></code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      The core idea is to repeatedly apply the reverse operation,
that makes the larger coordinate smaller,
until either (sx, sy) is reached,
or it becomes clear that it's impossible.

At any point (x, y):
If x &gt; y:
If x &gt; 2y &gt; y, (x, y) -&gt; (x / 2, y)
If 2y &gt;= x &gt; y, (x, y) -&gt; (x - y, y)

If y &gt; x, similarly.
If x == y, it becomes (0, y) or (x, 0)


    </Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Minimum Moves to Reach Target in Grid" lines
# @param {Integer} sx
# @param {Integer} sy
# @param {Integer} tx
# @param {Integer} ty
# @return {Integer}
def min_moves(sx, sy, tx, ty)
  steps = 0
  while tx>sx || ty>sy
    steps+=1

    if tx<ty # instead of doing same check for y, swap to make tx bigger always
      tx, ty, sx, sy = ty, tx, sy, sx
    end

    if tx==ty
      if sx==0
        tx=0
      elsif sy==0
        ty=0;
      else
        return -1
      end
    elsif tx> 2*ty
      return -1 if tx%2 == 1
      tx/=2
    else
      tx-=ty
    end
  end

  return (tx==sx && ty==sy) ? steps : -1
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>