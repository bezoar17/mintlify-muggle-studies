---
title: "❗️ Next Greater Element IV"
description: '[leetcode link](https://leetcode.com/problems/next-greater-element-iv/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given a <strong>0-indexed</strong> array of non-negative integers <code>nums</code>. For each integer in <code>nums</code>, you must find its respective <strong>second greater</strong> integer.</p>  <p>The <strong>second greater</strong> integer of <code>nums[i]</code> is <code>nums[j]</code> such that:</p>  <ul>  <li><code>j &gt; i</code></li>  <li><code>nums[j] &gt; nums[i]</code></li>  <li>There exists <strong>exactly one</strong> index <code>k</code> such that <code>nums[k] &gt; nums[i]</code> and <code>i &lt; k &lt; j</code>.</li> </ul>  <p>If there is no such <code>nums[j]</code>, the second greater integer is considered to be <code>-1</code>.</p>  <ul>  <li>For example, in the array <code>[1, 2, 4, 3]</code>, the second greater integer of <code>1</code> is <code>4</code>, <code>2</code> is <code>3</code>,&nbsp;and that of <code>3</code> and <code>4</code> is <code>-1</code>.</li> </ul>  <p>Return<em> an integer array </em><code>answer</code><em>, where </em><code>answer[i]</code><em> is the second greater integer of </em><code>nums[i]</code><em>.</em></p>   <p><strong class="example">Example 1:</strong></p>   <strong>Input:</strong> nums = [2,4,0,9,6] <br/> <strong>Output:</strong> [9,6,6,-1,-1] <br/> <strong>Explanation:</strong> 0th index: 4 is the first integer greater than 2, and 9 is the second integer greater than 2, to the right of 2. 1st index: 9 is the first, and 6 is the second integer greater than 4, to the right of 4. 2nd index: 9 is the first, and 6 is the second integer greater than 0, to the right of 0. 3rd index: There is no integer greater than 9 to its right, so the second greater integer is considered to be -1. 4th index: There is no integer greater than 6 to its right, so the second greater integer is considered to be -1. Thus, we return [9,6,6,-1,-1].   <p><strong class="example">Example 2:</strong></p>   <strong>Input:</strong> nums = [3,3] <br/> <strong>Output:</strong> [-1,-1] <br/> <strong>Explanation:</strong> We return [-1,-1] since neither integer has any integer greater than it.    <p><strong>Constraints:</strong></p>  <ul>  <li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>  <li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      When finding next greater element, and going from R-&gt;L, stack is mono-decreasing
If we encounter an element, we remove all elements from stack which are &lt;= current one. All these values are to the right of current element, and are &lt;= current one
we can binary search on discarded elements, for the second greater value.

In each iteration, we add current element to the stack, and it becomes the top. For this we might or might not discard nums from the stack. If we do discard, we store for this current element what elements were discarded.

Before we add to the stack, we record which numbers were discarded.

Now that all nums have been discarded. If nothing was discarded for the top element, the next in stack is the answer.

If discarded_elements[top_of_stack], has any number that is greater than current element, we use that as answer. This array is sorted, as stack is always mono-decreasing. If there is no num here, then use next in stack as answer.
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Next Greater Element IV" lines
# @param {Integer[]} nums
# @return {Integer[]}
def second_greater_element(nums)
  n = nums.size
  discard_fn=->(top,num) { top<=num }
  discarded_nums = Hash.new {|h,k| h[k]=[]} # stores nums, not idxs, bcoz we will do binary search on this
  answer = Array.new(n, -1) # default is set to -1 already
  
  stack = [] # stores only the index of element, not [element, idx]

  (n-1).downto(0).each do |idx|
    # discard and clear stack for the current element, and record discarded pile
    discarded_nums[idx] << nums[stack.pop] while !stack.empty? && discard_fn.call(nums[stack.last], nums[idx])
    
    # if top is empty, answer is -1, skip
    unless stack.empty?
      next_in_stack = (stack.size > 1) ? nums[stack[-2]] : -1

      # search answer in discarded values for top of stack, if not found, answer is next element in stack
      answer[idx] = discarded_nums[stack.last].bsearch { |x| x > nums[idx] } || next_in_stack
    end
    
    stack << idx # current element is always at top of stack
  end
  answer
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>