---
title: "ðŸ§€ Longest Semi-Repeating Subarray"
description: '[leetcode link](https://leetcode.com/problems/longest-semi-repeating-subarray/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given an integer arrayâ€¯<code>nums</code> of lengthâ€¯<code>n</code> and an integerâ€¯<code>k</code>.</p>  <p>A <strong>semiâ€‘repeating</strong> subarray is a contiguous subarray in which at mostâ€¯<code>k</code>â€¯elements repeat (i.e., appear more than once).</p>  <p>Return the length of the longest <strong>semiâ€‘repeating</strong> subarray inâ€¯<code>nums</code>.</p>   <p><strong class="example">Example 1:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">nums = [1,2,3,1,2,3,4], k = 2</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">6</span></p>  <p><br/> <strong>Explanation:</strong></p>  <p>The longest semi-repeating subarray is <code>[2, 3, 1, 2, 3, 4]</code>, which has two repeating elements (2 and 3).</p> </div>  <p><strong class="example">Example 2:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">nums = [1,1,1,1,1], k = 4</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">5</span></p>  <p><br/> <strong>Explanation:</strong></p>  <p>The longest semi-repeating subarray is <code>[1, 1, 1, 1, 1]</code>, which has only one repeating element (1).</p> </div>  <p><strong class="example">Example 3:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">nums = [1,1,1,1,1], k = 0</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">1</span></p>  <p><br/> <strong>Explanation:</strong></p>  <p>The longest semi-repeating subarray is <code>[1]</code>, which has no repeating elements.</p> </div>   <p><strong>Constraints:</strong></p>  <ul>  <li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>  <li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>  <li><code>0 &lt;= k &lt;= nums.length</code></li> </ul>   <style type="text/css">.spoilerbutton &lbrace;display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; &rbrace; .spoiler &lbrace;overflow:hidden;&rbrace; .spoiler > div &lbrace;-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;&rbrace; .spoilerbutton[value="Show Message"] + .spoiler > div &lbrace;margin-top:-2000%;&rbrace; .spoilerbutton[value="Hide Message"] + .spoiler &lbrace;padding:5px;&rbrace; </style> <input class="spoilerbutton" onclick="this.value=this.value=='Show Message'?'Hide Message':'Show Message';" type="button" value="Show Message" /> <div class="spoiler"> <div> <p><strong>FOR TESTING ONLY. WILL BE DELETED LATER.</strong></p> // Model solution has runtime of O(n log n), O(n*n) and above should TLE.   # Bromelia  import sys import random, json, string import math import datetime from collections import defaultdict ri = random.randint  MAX_N   = 100_000 MAX_VAL = 100_000  def randomString(n, allowed):     return &#39;&#39;.join(random.choices(allowed, k=n))  def randomUnique(x, y, n):     return random.sample(range(x, y + 1), n)  def randomArray(x, y, n):     return [ri(x, y) for _ in range(n)]  def shuffle(arr):     random.shuffle(arr)     return arr  def pr(a):     file.write(str(a).replace(&quot; &quot;, &quot;&quot;).replace(&quot;{${question_content}$}#39;&quot;, &quot;{${question_content}$}quot;&quot;).replace(&quot;{${question_content}$}quot;null{${question_content}$}quot;&quot;, &quot;null&quot;) + &#39;\n&#39;)  def prstr(a):     pr(&quot;{${question_content}$}quot;&quot; + a + &quot;{${question_content}$}quot;&quot;)   def prtc(tc):     nums, k = tc     pr(nums)     pr(k)      def examples():     yield ([1, 2, 3, 1, 2, 3, 4], 2)     yield ([1, 1, 1, 1, 1], 4)     yield ([1, 1, 1, 1, 1], 0)  def smallCases():     yield ([MAX_VAL], 0)     yield ([MAX_VAL], 1)      for len in range(1, 3 + 1):         nums = [0] * len          def recursiveGenerate(idx: int):             if idx == len:                 for k in range(0, len + 1):                     yield (nums, k)             else:                 for nextElement in range(1, len + 1):                     nums[idx] = nextElement                     yield from recursiveGenerate(idx + 1)          yield from recursiveGenerate(0)  def randomCases():     params = [         (    4,    20,      10, 400),         (   21,  2000,    1000, 100),         (MAX_N, MAX_N,      10,   2),         (MAX_N, MAX_N,     500,   2),         (MAX_N, MAX_N, MAX_VAL,   2),     ]     for minLen, maxLen, maxVal, testCount in params:         for _ in range(testCount):             len = ri(minLen, maxLen)             k = ri(1, len)              nums = [0] * len             for i in range(len):                 nums[i] = ri(1, maxVal)                      yield (nums, k)  def cornerCases():     yield ([MAX_VAL] * MAX_N, 0)     yield ([MAX_VAL] * MAX_N, MAX_N)     yield ([i for i in range(1, MAX_N + 1)], 0)     yield ([i for i in range(1, MAX_N + 1)], MAX_N)     yield ([i // 2 + 1 for i in range(MAX_N)], MAX_N // 2 - 1)     yield ([i % (MAX_N // 2) + 1 for i in range(MAX_N)], MAX_N // 2 - 1)   with open(&#39;test.txt&#39;, &#39;w&#39;) as file:     random.seed(0)     for tc in examples(): prtc(tc)     for tc in smallCases(): prtc(tc)     for tc in sorted(list(randomCases()), key = lambda x: len(x[0])): prtc(tc)     for tc in cornerCases(): prtc(tc)  </div> </div> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Classing sliding window (expand and shrink)

Adjust sliding window. And keep track of frequency within window, and repeated element count within window. Expand r first, if new element is new, nothing to do, else update repeated count, if freq of element being added was 1, it is being repeated, if repeated count is more than k, shrink window from left. Here, remove elements from left until we remove a repeated element, i.e its freq after removal would be 1.

In short, element's freq before being added and after being removed, if its 1, then that element is a repeated element wrt to the window. Use this to update repeated element count in the window, and expand and shrink the window accordingly.
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Longest Semi-Repeating Subarray" lines
# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer}
def longest_subarray(nums, k)
  freq = Hash.new(0)
  l = repeated = 0
  
  (0...nums.size).reduce(0) do |max_len, r|
    repeated+=1 if freq[nums[r]] == 1 # new repeating element
    freq[nums[r]]+=1

    while repeated > k # adjust window from left
      freq[nums[l]]-=1
      repeated-=1 if freq[nums[l]] == 1 # repeated element going out
      l+=1
    end

    [max_len, r-l+1].max
  end
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>