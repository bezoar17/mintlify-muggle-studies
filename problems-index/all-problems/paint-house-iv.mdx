---
title: 'ðŸ§€ Paint House IV'
description: '[leetcode link](https://leetcode.com/problems/paint-house-iv/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given an <strong>even</strong> integer <code>n</code> representing the number of houses arranged in a straight line, and a 2D array <code>cost</code> of size <code>n x 3</code>, where <code>cost[i][j]</code> represents the cost of painting house <code>i</code> with color <code>j + 1</code>.</p>  <p>The houses will look <strong>beautiful</strong> if they satisfy the following conditions:</p>  <ul>  <li>No <strong>two</strong> adjacent houses are painted the same color.</li>  <li>Houses <strong>equidistant</strong> from the ends of the row are <strong>not</strong> painted the same color. For example, if <code>n = 6</code>, houses at positions <code>(0, 5)</code>, <code>(1, 4)</code>, and <code>(2, 3)</code> are considered equidistant.</li> </ul>  <p>Return the <strong>minimum</strong> cost to paint the houses such that they look <strong>beautiful</strong>.</p>   <p><strong class="example">Example 1:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">n = 4, cost = [[3,5,7],[6,2,9],[4,8,1],[7,3,5]]</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">9</span></p>  <p><br/> <strong>Explanation:</strong></p>  <p>The optimal painting sequence is <code>[1, 2, 3, 2]</code> with corresponding costs <code>[3, 2, 1, 3]</code>. This satisfies the following conditions:</p>  <ul>  <li>No adjacent houses have the same color.</li>  <li>Houses at positions 0 and 3 (equidistant from the ends) are not painted the same color <code>(1 != 2)</code>.</li>  <li>Houses at positions 1 and 2 (equidistant from the ends) are not painted the same color <code>(2 != 3)</code>.</li> </ul>  <p>The minimum cost to paint the houses so that they look beautiful is <code>3 + 2 + 1 + 3 = 9</code>.</p> </div>  <p><strong class="example">Example 2:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">n = 6, cost = [[2,4,6],[5,3,8],[7,1,9],[4,6,2],[3,5,7],[8,2,4]]</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">18</span></p>  <p><br/> <strong>Explanation:</strong></p>  <p>The optimal painting sequence is <code>[1, 3, 2, 3, 1, 2]</code> with corresponding costs <code>[2, 8, 1, 2, 3, 2]</code>. This satisfies the following conditions:</p>  <ul>  <li>No adjacent houses have the same color.</li>  <li>Houses at positions 0 and 5 (equidistant from the ends) are not painted the same color <code>(1 != 2)</code>.</li>  <li>Houses at positions 1 and 4 (equidistant from the ends) are not painted the same color <code>(3 != 1)</code>.</li>  <li>Houses at positions 2 and 3 (equidistant from the ends) are not painted the same color <code>(2 != 3)</code>.</li> </ul>  <p>The minimum cost to paint the houses so that they look beautiful is <code>2 + 8 + 1 + 2 + 3 + 2 = 18</code>.</p> </div>   <p><strong>Constraints:</strong></p>  <ul>  <li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>  <li><code>n</code> is even.</li>  <li><code>cost.length == n</code></li>  <li><code>cost[i].length == 3</code></li>  <li><code>0 &lt;= cost[i][j] &lt;= 10<sup>5</sup></code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      If you fix colour of i, for i+1, there are again 3 options, acc. to normal paint house problem.

But in this case, for each colour of i, you have 2 options, i.e, colour of i, and colour of n-i. 

For the next house, you calculate 6 states again, based on previous houses state.

Doing this, we can go from 1 to mid, as we are storing states for i, and n-i together.

    </Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Paint House IV" lines
# @param {Integer} n
# @param {Integer[][]} cost
# @return {Integer}
def min_cost(n, cost)
  mid = n/2   # mid no. of pairs of equidistant houses
  # 6 possible states here, for each color of house i, 2 choices for n-1-i
  # for each idx, values for 6 states of the idx can be calculated based on previous pairs states
  last_color_pair = Array.new(6, 0)
  last_color_pair[0] = cost[0][0] + cost[n-1][1] # i->0, n-1 -> 1
  last_color_pair[1] = cost[0][0] + cost[n-1][2] # i->0, n-1 -> 2
  last_color_pair[2] = cost[0][1] + cost[n-1][2] # i->1, n-1 -> 0
  last_color_pair[3] = cost[0][1] + cost[n-1][0] # i->1, n-1 -> 2
  last_color_pair[4] = cost[0][2] + cost[n-1][0] # i->2, n-1 -> 0
  last_color_pair[5] = cost[0][2] + cost[n-1][1] # i->2, n-1 -> 1
  
  (1...mid).each do |i|
    curr_color_pair = Array.new(6, 0)
    # i -> 0, ni -> 1, so i-1 can be 1 or 2 and n(i-1) can be (0 or 2) or (0 or 1); 4 possible previous states
    # but since ni is 1, n(i-1) cant be 1, so only 3 states are valid from previous;
    curr_color_pair[0] = cost[i][0] + cost[n-i-1][1] + [last_color_pair[2], last_color_pair[3], last_color_pair[4]].min
    curr_color_pair[1] = cost[i][0] + cost[n-i-1][2] + [last_color_pair[3], last_color_pair[4], last_color_pair[5]].min 
    curr_color_pair[2] = cost[i][1] + cost[n-i-1][2] + [last_color_pair[0], last_color_pair[4], last_color_pair[5]].min
    curr_color_pair[3] = cost[i][1] + cost[n-i-1][0] + [last_color_pair[0], last_color_pair[1], last_color_pair[5]].min
    curr_color_pair[4] = cost[i][2] + cost[n-i-1][0] + [last_color_pair[0], last_color_pair[1], last_color_pair[2]].min
    curr_color_pair[5] = cost[i][2] + cost[n-i-1][1] + [last_color_pair[1], last_color_pair[2], last_color_pair[3]].min
    last_color_pair = curr_color_pair # update for next iteration
  end
  
  last_color_pair.min
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>