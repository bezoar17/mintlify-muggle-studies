---
title: "❗️ Maximize the Number of Target Nodes After Connecting Trees II"
description: '[leetcode link](https://leetcode.com/problems/maximize-the-number-of-target-nodes-after-connecting-trees-ii/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>There exist two <strong>undirected </strong>trees with <code>n</code> and <code>m</code> nodes, labeled from <code>[0, n - 1]</code> and <code>[0, m - 1]</code>, respectively.</p>  <p>You are given two 2D integer arrays <code>edges1</code> and <code>edges2</code> of lengths <code>n - 1</code> and <code>m - 1</code>, respectively, where <code>edges1[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the first tree and <code>edges2[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> indicates that there is an edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> in the second tree.</p>  <p>Node <code>u</code> is <strong>target</strong> to node <code>v</code> if the number of edges on the path from <code>u</code> to <code>v</code> is even.&nbsp;<strong>Note</strong> that a node is <em>always</em> <strong>target</strong> to itself.</p>  <p>Return an array of <code>n</code> integers <code>answer</code>, where <code>answer[i]</code> is the <strong>maximum</strong> possible number of nodes that are <strong>target</strong> to node <code>i</code> of the first tree if you had to connect one node from the first tree to another node in the second tree.</p>  <p><strong>Note</strong> that queries are independent from each other. That is, for every query you will remove the added edge before proceeding to the next query.</p>   <p><strong class="example">Example 1:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">edges1 = [[0,1],[0,2],[2,3],[2,4]], edges2 = [[0,1],[0,2],[0,3],[2,7],[1,4],[4,5],[4,6]]</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">[8,7,7,8,8]</span></p>  <p><br/> <strong>Explanation:</strong></p>  <ul>  <li>For <code>i = 0</code>, connect node 0 from the first tree to node 0 from the second tree.</li>  <li>For <code>i = 1</code>, connect node 1 from the first tree to node 4 from the second tree.</li>  <li>For <code>i = 2</code>, connect node 2 from the first tree to node 7 from the second tree.</li>  <li>For <code>i = 3</code>, connect node 3 from the first tree to node 0 from the second tree.</li>  <li>For <code>i = 4</code>, connect node 4 from the first tree to node 4 from the second tree.</li> </ul> <img alt="" src="https://assets.leetcode.com/uploads/2024/09/24/3982-1.png" style="width: 600px; height: 169px;" /></div>  <p><strong class="example">Example 2:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">edges1 = [[0,1],[0,2],[0,3],[0,4]], edges2 = [[0,1],[1,2],[2,3]]</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">[3,6,6,6,6]</span></p>  <p><br/> <strong>Explanation:</strong></p>  <p>For every <code>i</code>, connect node <code>i</code> of the first tree with any node of the second tree.</p> <img alt="" src="https://assets.leetcode.com/uploads/2024/09/24/3928-2.png" style="height: 281px; width: 500px;" /></div>   <p><strong>Constraints:</strong></p>  <ul>  <li><code>2 &lt;= n, m &lt;= 10<sup>5</sup></code></li>  <li><code>edges1.length == n - 1</code></li>  <li><code>edges2.length == m - 1</code></li>  <li><code>edges1[i].length == edges2[i].length == 2</code></li>  <li><code>edges1[i] = [a<sub>i</sub>, b<sub>i</sub>]</code></li>  <li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>  <li><code>edges2[i] = [u<sub>i</sub>, v<sub>i</sub>]</code></li>  <li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; m</code></li>  <li>The input is generated such that <code>edges1</code> and <code>edges2</code> represent valid trees.</li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Level Order Traversal using BFS. Starting node is 0, and level is also 0. All nodes within odd levels and all nodes within even levels have even edges between them. So, if we bisect all nodes into them being part of even or odd level. We can calculate count of odd nodes, and even nodes for each node which would depend on nodes level. Only 1 bfs gives us this. Now our answer is even_node_count_t1[i] + odd_max_t2.
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Maximize the Number of Target Nodes After Connecting Trees II" lines
# @param {Integer[][]} edges1
# @param {Integer[][]} edges2
# @return {Integer[]}
def max_target_nodes(edges1, edges2)
  odd_count_t2, even_count_t2 = odd_even_count(edges2)
  odd_count_t1, even_count_t1 = odd_even_count(edges1)
  n=edges1.size+1; t2_odd_count = odd_count_t2.max

  (0...n).map do |i|
    even_count_t1[i] + t2_odd_count
  end
end

# for each start_node, node_count of nodes where path from start_node to node has odd/even edges
# needs to be O(n) acc. to given constraints
def odd_even_count(edges)
  n=edges.size+1
  adj_h = Hash.new {|h,k| h[k]=[]}; edges.each {|u,v| adj_h[u]<<v; adj_h[v]<<u;}
  odd_counts = Array.new(n,0)
  even_counts = Array.new(n,1)

  levels = Array.new(n,-1) # visited and level odd/even array
  level_nodes = []
  level_nodes << 0; current_level = 0; # initialization

  until level_nodes.empty?
    nodes_in_level = level_nodes.dup; level_nodes=[]; # copy and reset level nodes for next level
    nodes_in_level.each do |node|
      levels[node] = current_level%2
      adj_h[node].select{|x| levels[x]==-1 }.each {|x| level_nodes<<x}
    end
    current_level+=1
  end

  odd_level_count = levels.count {|x| x==1}
  even_level_count = levels.count {|x| x==0}

  (0...n).each do |node|
    odd_counts[node] = levels[node] == 0 ? odd_level_count : even_level_count
    even_counts[node] = levels[node] == 0 ? even_level_count : odd_level_count
  end

  [odd_counts, even_counts]
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>