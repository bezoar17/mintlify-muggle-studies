---
title: "❗️ Frog Position After T Seconds"
description: '[leetcode link](https://leetcode.com/problems/frog-position-after-t-seconds/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>Given an undirected tree consisting of <code>n</code> vertices numbered from <code>1</code> to <code>n</code>. A frog starts jumping from <strong>vertex 1</strong>. In one second, the frog jumps from its current vertex to another <strong>unvisited</strong> vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices, it jumps randomly to one of them with the same probability. Otherwise, when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.</p>  <p>The edges of the undirected tree are given in the array <code>edges</code>, where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> means that exists an edge connecting the vertices <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>.</p>  <p><em>Return the probability that after <code>t</code> seconds the frog is on the vertex <code>target</code>. </em>Answers within <code>10<sup>-5</sup></code> of the actual answer will be accepted.</p>   <p><strong class="example">Example 1:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2021/12/21/frog1.jpg" style="width: 338px; height: 304px;" />  <strong>Input:</strong> n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4 <br/> <strong>Output:</strong> 0.16666666666666666  <br/> <strong>Explanation:</strong> The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after <strong>second 1</strong> and then jumping with 1/2 probability to vertex 4 after <strong>second 2</strong>. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666.    <p><strong class="example">Example 2:</strong></p> <strong><img alt="" src="https://assets.leetcode.com/uploads/2021/12/21/frog2.jpg" style="width: 304px; height: 304px;" /></strong>   <strong>Input:</strong> n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7 <br/> <strong>Output:</strong> 0.3333333333333333 <strong>Explanation: </strong>The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after <strong>second 1</strong>.     <p><strong>Constraints:</strong></p>  <ul>  <li><code>1 &lt;= n &lt;= 100</code></li>  <li><code>edges.length == n - 1</code></li>  <li><code>edges[i].length == 2</code></li>  <li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>  <li><code>1 &lt;= t &lt;= 50</code></li>  <li><code>1 &lt;= target &lt;= n</code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Either you reach target at time t, or reach target and keep jumping over there itself. Else, just propagate the state with normal bfs.
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Frog Position After T Seconds" lines
# @param {Integer} n
# @param {Integer[][]} edges
# @param {Integer} t
# @param {Integer} target
# @return {Float}
def frog_position(n, edges, t, target)
  # reach target within t time(dist) and just multiply the probability in each path
  # and sum the probabilities of different paths to get final probability
  adj_h = Hash.new { |h,k| h[k]=[] }
  edges.each {|a,b| adj_h[a]<<b; adj_h[b]<<a; }

  return 0.0 if t!=1 && target==1 && edges.size > 0
  return 1.0 if n==1 && target==1 && t==1


  visited = Set.new
  queue = Queue.new
  queue << [1, 0, 1.0]; visited.add(1);

  until queue.empty?
    node, time, probability = queue.pop

    return probability if (node == target && (time == t || (adj_h[node].size == 1 && time <=t)))

    adj_h[node].each do |neighbor|
      unless visited.include?(neighbor)
        visited.add(neighbor)
        if node ==1
          queue << [neighbor, time+1, probability/(adj_h[node].size)]
        else
          queue << [neighbor, time+1, probability/(adj_h[node].size-1)]
        end
      end
    end
  end

  0.0
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>