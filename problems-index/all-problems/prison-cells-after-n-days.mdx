---
title: 'ðŸ§€ Prison Cells After N Days'
description: '[leetcode link](https://leetcode.com/problems/prison-cells-after-n-days/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>There are <code>8</code> prison cells in a row and each cell is either occupied or vacant.</p>  <p>Each day, whether the cell is occupied or vacant changes according to the following rules:</p>  <ul>  <li>If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied.</li>  <li>Otherwise, it becomes vacant.</li> </ul>  <p><strong>Note</strong> that because the prison is a row, the first and the last cells in the row can&#39;t have two adjacent neighbors.</p>  <p>You are given an integer array <code>cells</code> where <code>cells[i] == 1</code> if the <code>i<sup>th</sup></code> cell is occupied and <code>cells[i] == 0</code> if the <code>i<sup>th</sup></code> cell is vacant, and you are given an integer <code>n</code>.</p>  <p>Return the state of the prison after <code>n</code> days (i.e., <code>n</code> such changes described above).</p>   <p><strong class="example">Example 1:</strong></p>   <strong>Input:</strong> cells = [0,1,0,1,1,0,0,1], n = 7 <br/> <strong>Output:</strong> [0,0,1,1,0,0,0,0] <br/> <strong>Explanation:</strong> The following table summarizes the state of the prison on each day: Day 0: [0, 1, 0, 1, 1, 0, 0, 1] Day 1: [0, 1, 1, 0, 0, 0, 0, 0] Day 2: [0, 0, 0, 0, 1, 1, 1, 0] Day 3: [0, 1, 1, 0, 0, 1, 0, 0] Day 4: [0, 0, 0, 0, 0, 1, 0, 0] Day 5: [0, 1, 1, 1, 0, 1, 0, 0] Day 6: [0, 0, 1, 0, 1, 1, 0, 0] Day 7: [0, 0, 1, 1, 0, 0, 0, 0]   <p><strong class="example">Example 2:</strong></p>   <strong>Input:</strong> cells = [1,0,0,1,0,0,1,0], n = 1000000000 <br/> <strong>Output:</strong> [0,0,1,1,1,1,1,0]    <p><strong>Constraints:</strong></p>  <ul>  <li><code>cells.length == 8</code></li>  <li><code>cells[i]</code>&nbsp;is either <code>0</code> or <code>1</code>.</li>  <li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Starting and ending will always be 0.

Suppose starting-state is 0,b,c,d,e,f,g,0. 

Suppose we reversed representation of 0, 1 for occupied and vacant. Then we can use xor to calculate
states, and doing a dry run , we see that after 7 iterations, state becomes 0,g,f,e,d,c,b,0. Exact reverse. 

So, we just see if reversal is needed for starting state based on n, 
Now we just apply remaining transformations which would be less than 7.

Remember, this is valid for starting state of 0,b,c,d,e,f,g,0. 

So if we have 1 in first or last element of cells, we first get our starting state by doing 1 transformation on it.
    </Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Prison Cells After N Days" lines
# @param {Integer[]} cells
# @param {Integer} n
# @return {Integer[]}
def prison_after_n_days(cells, n)
  transformation = ->(arr) { 
    new_state = Array.new(8,0)
    (1..6).each { |i| new_state[i] = (1 - arr[i-1] ^ arr[i+1]) }
    new_state
  }

  iterations = n; state = cells;
  if cells.first == 1 || cells.last == 1
    # prepare base state
    iterations -=1
    state = transformation.call(cells);
    state[0] = 0; state[7] = 0;
  end

  reversals = iterations/7;
  actual_iterations = iterations%7;

  state.reverse! if reversals.odd?
  
  actual_iterations.times do
    state = transformation.call(state)
  end

  state
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>