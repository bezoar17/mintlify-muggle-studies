---
title: "ðŸ§€ Partition Labels"
description: '[leetcode link](https://leetcode.com/problems/partition-labels/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given a string <code>s</code>. We want to partition the string into as many parts as possible so that each letter appears in at most one part. For example, the string <code>&quot;ababcc&quot;</code> can be partitioned into <code>[&quot;abab&quot;, &quot;cc&quot;]</code>, but partitions such as <code>[&quot;aba&quot;, &quot;bcc&quot;]</code> or <code>[&quot;ab&quot;, &quot;ab&quot;, &quot;cc&quot;]</code> are invalid.</p>  <p>Note that the partition is done so that after concatenating all the parts in order, the resultant string should be <code>s</code>.</p>  <p>Return <em>a list of integers representing the size of these parts</em>.</p>   <p><strong class="example">Example 1:</strong></p>   <strong>Input:</strong> s = &quot;ababcbacadefegdehijhklij&quot; <br/> <strong>Output:</strong> [9,7,8] <br/> <strong>Explanation:</strong> The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;. This is a partition so that each letter appears in at most one part. A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits s into less parts.   <p><strong class="example">Example 2:</strong></p>   <strong>Input:</strong> s = &quot;eccbbbbdec&quot; <br/> <strong>Output:</strong> [10]    <p><strong>Constraints:</strong></p>  <ul>  <li><code>1 &lt;= s.length &lt;= 500</code></li>  <li><code>s</code> consists of lowercase English letters.</li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      No notes for this problem
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Partition Labels" lines
# @param {String} s
# @return {Integer[]}
def partition_labels(s)
  range_h = {}

  s.chars.each_with_index do |ch, idx|
    if range_h.include?(ch)
      t = range_h[ch]; t[-1] = idx
      range_h[ch] = t
    else
      range_h[ch] = [idx, idx]
    end
  end

  interval_sizes = [];
  current_interval = [0, 0]

  range_h.values.each do |first, last|
    overlapping = first<= current_interval[-1]

    if !overlapping
      # start of new interval
      interval_sizes << (current_interval[-1] - current_interval[0] + 1)
      current_interval[0] = first
    end
    
    current_interval[-1] = [current_interval[-1], last].max
  end
  interval_sizes << (current_interval[-1] - current_interval[0] + 1)

  interval_sizes
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>