---
title: "ðŸ§€ Maximum XOR After Operations "
description: '[leetcode link](https://leetcode.com/problems/maximum-xor-after-operations/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>. In one operation, select <strong>any</strong> non-negative integer <code>x</code> and an index <code>i</code>, then <strong>update</strong> <code>nums[i]</code> to be equal to <code>nums[i] AND (nums[i] XOR x)</code>.</p>  <p>Note that <code>AND</code> is the bitwise AND operation and <code>XOR</code> is the bitwise XOR operation.</p>  <p>Return <em>the <strong>maximum</strong> possible bitwise XOR of all elements of </em><code>nums</code><em> after applying the operation <strong>any number</strong> of times</em>.</p>   <p><strong class="example">Example 1:</strong></p>   <strong>Input:</strong> nums = [3,2,4,6] <br/> <strong>Output:</strong> 7 <br/> <strong>Explanation:</strong> Apply the operation with x = 4 and i = 3, num[3] = 6 AND (6 XOR 4) = 6 AND 2 = 2. Now, nums = [3, 2, 4, 2] and the bitwise XOR of all the elements = 3 XOR 2 XOR 4 XOR 2 = 7. It can be shown that 7 is the maximum possible bitwise XOR. Note that other operations may be used to achieve a bitwise XOR of 7.  <p><strong class="example">Example 2:</strong></p>   <strong>Input:</strong> nums = [1,2,3,9,2] <br/> <strong>Output:</strong> 11 <br/> <strong>Explanation:</strong> Apply the operation zero times. The bitwise XOR of all the elements = 1 XOR 2 XOR 3 XOR 9 XOR 2 = 11. It can be shown that 11 is the maximum possible bitwise XOR.   <p><strong>Constraints:</strong></p>  <ul>  <li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>  <li><code>0 &lt;= nums[i] &lt;= 10<sup>8</sup></code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      **Bit manipulation **

Suppose max_bits in num is 3. Then, max is when we can get all 1s. 

n^x will give us whatever we want, at every bit, but after & with n, bits which are 0, will always be zero. For any 1 bit in any number , now that position we can manipulate the bit so that in the end result of that bit is 1.

So, the bit place where there isnt any 1, only 0s, those will remain 0 in the end after all xors. 
All other positions can be controlled to be forced to 1, and that would be the maximum value. 
Now to see if there is any 1 in a bit position, we can OR all numbers.
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Maximum XOR After Operations " lines
# @param {Integer[]} nums
# @return {Integer}
def maximum_xor(nums)
  nums.reduce(0) {|res, num| res|num}
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>