---
title: "❗️ Swim in Rising Water"
description: '[leetcode link](https://leetcode.com/problems/swim-in-rising-water/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given an <code>n x n</code> integer matrix <code>grid</code> where each value <code>grid[i][j]</code> represents the elevation at that point <code>(i, j)</code>.</p>  <p>It starts raining, and water gradually rises over time. At time <code>t</code>, the water level is <code>t</code>, meaning <strong>any</strong> cell with elevation less than equal to <code>t</code> is submerged or reachable.</p>  <p>You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most <code>t</code>. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.</p>  <p>Return <em>the minimum time until you can reach the bottom right square </em><code>(n - 1, n - 1)</code><em> if you start at the top left square </em><code>(0, 0)</code>.</p>   <p><strong class="example">Example 1:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2021/06/29/swim1-grid.jpg" style="width: 164px; height: 165px;" />  <strong>Input:</strong> grid = [[0,2],[1,3]] <br/> <strong>Output:</strong> 3 Explanation: At time 0, you are in grid location (0, 0). You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0. You cannot reach point (1, 1) until time 3. When the depth of water is 3, we can swim anywhere inside the grid.   <p><strong class="example">Example 2:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2021/06/29/swim2-grid-1.jpg" style="width: 404px; height: 405px;" />  <strong>Input:</strong> grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]] <br/> <strong>Output:</strong> 16 <br/> <strong>Explanation:</strong> The final route is shown. We need to wait until time 16 so that (0, 0) and (4, 4) are connected.    <p><strong>Constraints:</strong></p>  <ul>  <li><code>n == grid.length</code></li>  <li><code>n == grid[i].length</code></li>  <li><code>1 &lt;= n &lt;= 50</code></li>  <li><code>0 &lt;= grid[i][j] &lt;&nbsp;n<sup>2</sup></code></li>  <li>Each value <code>grid[i][j]</code> is <strong>unique</strong>.</li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      2 Solutions

First is do a binary search on the solution space to find minimum, and a dfs/bfs to check if solution works for a given t. lower bound is max of starting and ending points, higher bound is max grid value found throughout the grid.


Second solution is to do a modified Djikstra's search, taking minimum neighbouring t value (kind of like edge value), and stopping when you reach n-1, n-1.

So, use min heap while doing djikstra.

In the second solution, you are essentially, only going to the next node which takes least amount of time, and processing all those first(adding all those to the visited set first), and as soon as the time comes to add n-1,n-1 node, you will have taken the least time, as processing is happening out of a min heap.
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Swim in Rising Water" lines
def swim_in_water(grid)
  rows = columns = grid.length - 1
  
  visited = Set.new
  heap = Containers::MinHeap.new([[grid[0][0], 0, 0]])
  visited.add([0, 0])

  directions = ->(row, column) { [[1, 0],[-1, 0],[0, 1],[0, -1]].map { |x, y| [row + x, column + y] } }
  in_bounds = ->(row, column) { row.between?(0, rows) && column.between?(0, columns) }
  directions_in_bounds_and_unvisited = ->(row, column) { directions.call(row, column).select { |r, c| in_bounds.call(r, c) }.select {|r,c| !visited.include?([r, c])} }

  until heap.empty?
    time, row, column = heap.pop

    if row == rows && column == columns
      return time
    end

    directions_in_bounds_and_unvisited.call(row, column).each do |(r, c)|
      visited.add([r, c])
      heap.push([[time, grid[r][c]].max, r, c])
    end
  end
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>