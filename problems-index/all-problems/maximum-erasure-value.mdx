---
title: "ðŸ§€ Maximum Erasure Value"
description: '[leetcode link](https://leetcode.com/problems/maximum-erasure-value/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given an array of positive integers <code>nums</code> and want to erase a subarray containing&nbsp;<strong>unique elements</strong>. The <strong>score</strong> you get by erasing the subarray is equal to the <strong>sum</strong> of its elements.</p>  <p>Return <em>the <strong>maximum score</strong> you can get by erasing <strong>exactly one</strong> subarray.</em></p>  <p>An array <code>b</code> is called to be a <span class="tex-font-style-it">subarray</span> of <code>a</code> if it forms a contiguous subsequence of <code>a</code>, that is, if it is equal to <code>a[l],a[l+1],...,a[r]</code> for some <code>(l,r)</code>.</p>   <p><strong class="example">Example 1:</strong></p>   <strong>Input:</strong> nums = [4,2,4,5,6] <br/> <strong>Output:</strong> 17 <br/> <strong>Explanation:</strong> The optimal subarray here is [2,4,5,6].   <p><strong class="example">Example 2:</strong></p>   <strong>Input:</strong> nums = [5,2,1,2,5,2,1,2,5] <br/> <strong>Output:</strong> 8 <br/> <strong>Explanation:</strong> The optimal subarray here is [5,2,1] or [1,2,5].    <p><strong>Constraints:</strong></p>  <ul>  <li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>  <li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      2 pointer maintaining valid array. Store hash of each num, start l,r both from 0. Increment right idx, if value was not seen, keep adding to subarray sum, else remove from sub-array, bring left idx to seen position+1, to make the array valid. During this shrink, also update seen hash and reduce sub-array sum.
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Maximum Erasure Value" lines
# @param {Integer[]} nums
# @return {Integer}
def maximum_unique_subarray(nums)
  # max subarray sum of unique elements
  left_idx = 0
  idx_hash = {}
  sb_sum = 0
  max_sb_sum = 0
  n = nums.size

  nums.each_with_index do |num, right_idx|
    sb_sum+=num

    unless idx_hash[num].nil?
      occur_idx = idx_hash[num]
      while left_idx <= occur_idx
        sb_sum-=nums[left_idx]
        idx_hash.delete(nums[left_idx])
        left_idx+=1
      end
    end
    
    idx_hash[num] = right_idx
    max_sb_sum = [max_sb_sum, sb_sum].max
  end

  max_sb_sum
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>