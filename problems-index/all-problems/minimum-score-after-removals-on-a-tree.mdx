---
title: '❗️ Minimum Score After Removals on a Tree'
description: '[leetcode link](https://leetcode.com/problems/minimum-score-after-removals-on-a-tree/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>There is an undirected connected tree with <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code> and <code>n - 1</code> edges.</p>  <p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> of length <code>n</code> where <code>nums[i]</code> represents the value of the <code>i<sup>th</sup></code> node. You are also given a 2D integer array <code>edges</code> of length <code>n - 1</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the tree.</p>  <p>Remove two <strong>distinct</strong> edges of the tree to form three connected components. For a pair of removed edges, the following steps are defined:</p>  <ol>  <li>Get the XOR of all the values of the nodes for <strong>each</strong> of the three components respectively.</li>  <li>The <strong>difference</strong> between the <strong>largest</strong> XOR value and the <strong>smallest</strong> XOR value is the <strong>score</strong> of the pair.</li> </ol>  <ul>  <li>For example, say the three components have the node values: <code>[4,5,7]</code>, <code>[1,9]</code>, and <code>[3,3,3]</code>. The three XOR values are <code>4 ^ 5 ^ 7 = <u><strong>6</strong></u></code>, <code>1 ^ 9 = <u><strong>8</strong></u></code>, and <code>3 ^ 3 ^ 3 = <u><strong>3</strong></u></code>. The largest XOR value is <code>8</code> and the smallest XOR value is <code>3</code>. The score is then <code>8 - 3 = 5</code>.</li> </ul>  <p>Return <em>the <strong>minimum</strong> score of any possible pair of edge removals on the given tree</em>.</p>   <p><strong class="example">Example 1:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2022/05/03/ex1drawio.png" style="width: 193px; height: 190px;" />  <strong>Input:</strong> nums = [1,5,5,4,11], edges = [[0,1],[1,2],[1,3],[3,4]] <br/> <strong>Output:</strong> 9 <br/> <strong>Explanation:</strong> The diagram above shows a way to make a pair of removals. - The 1<sup>st</sup> component has nodes [1,3,4] with values [5,4,11]. Its XOR value is 5 ^ 4 ^ 11 = 10. - The 2<sup>nd</sup> component has node [0] with value [1]. Its XOR value is 1 = 1. - The 3<sup>rd</sup> component has node [2] with value [5]. Its XOR value is 5 = 5. The score is the difference between the largest and smallest XOR value which is 10 - 1 = 9. It can be shown that no other pair of removals will obtain a smaller score than 9.   <p><strong class="example">Example 2:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2022/05/03/ex2drawio.png" style="width: 287px; height: 150px;" />  <strong>Input:</strong> nums = [5,5,2,4,4,2], edges = [[0,1],[1,2],[5,2],[4,3],[1,3]] <br/> <strong>Output:</strong> 0 <br/> <strong>Explanation:</strong> The diagram above shows a way to make a pair of removals. - The 1<sup>st</sup> component has nodes [3,4] with values [4,4]. Its XOR value is 4 ^ 4 = 0. - The 2<sup>nd</sup> component has nodes [1,0] with values [5,5]. Its XOR value is 5 ^ 5 = 0. - The 3<sup>rd</sup> component has nodes [2,5] with values [2,2]. Its XOR value is 2 ^ 2 = 0. The score is the difference between the largest and smallest XOR value which is 0 - 0 = 0. We cannot obtain a smaller score than 0.    <p><strong>Constraints:</strong></p>  <ul>  <li><code>n == nums.length</code></li>  <li><code>3 &lt;= n &lt;= 1000</code></li>  <li><code>1 &lt;= nums[i] &lt;= 10<sup>8</sup></code></li>  <li><code>edges.length == n - 1</code></li>  <li><code>edges[i].length == 2</code></li>  <li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>  <li><code>a<sub>i</sub> != b<sub>i</sub></code></li>  <li><code>edges</code> represents a valid tree.</li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      * sub-tree slicing
* ancestor-descendant relationships (in-out times)

First of all, get the xor for all nodes assuming they are root of a sub-tree, lets call this orig_xor for a node i. Now when we disconnect 2 edges, we will end up with 3 nodes which form 3 sub-trees. Atleast one of them will have the orig_xor value. The other 2 might not have orig_xor, some elements might have been removed from their trees. Now, think about how that can happen. There are actually only 3 scenarios. 

Suppose a root is fixed, and post the edge removal, we have u,v as roots of new components.
Case 1: u, v can be independent, 
Case 2/3 : u can be ancestor of v OR v can be ancestor of u

In Case1, both u and v will keep their orig_xor, and we have to recalculate the new xor for the 3rd component using orig_xor of u,v and the Total xor.

In Case 2, whichever is the descendant keeps the orig_xor, and we recalculate the new xor for ancestor and for root, using similar method, orig_xor and total xors of the components.

So, in order to simulate edge removal, we can simulate the picking new root heads, i.e u,v pairs amongst the n nodes. The edges being cut are between u,v and their parents.

And the xor calculation will be O(1), due to the pre-calculations of orig_xor for each nodes.

We, also have to calculate whether we will have case 1,2 or 3. i.e, check ancestor-descendant relationship between nodes. 

For that there are 2 methods, 1 simple but more storage, other more efficient but tricky( in-out timing record based).

Simple method is to just maintain a set of nodes in the sub-tree rooted at node, including itself. So, a hash of sets, for each node, and do a simple lookup.

Other method is, 
We use two arrays:
in[x] records the time when the traversal first enters node x.
out[x] records the time when the entire subtree rooted at x has been completely visited.
With this structure, we can determine ancestor-descendant relationships:
If node x is an ancestor of node y, then it must satisfy in[x]&lt;in[y]&lt;out[x].

We keep time outside the dfs, and track it globally.






    </Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Minimum Score After Removals on a Tree" lines
# @param {Integer[]} nums
# @param {Integer[][]} edges
# @return {Integer}
def minimum_score(nums, edges)
  n = nums.size
  graph = Hash.new {|h,k| h[k] =[]}
  edges.each {|u,v| graph[u]<<v; graph[v]<<u}

  subtree_xor = Array.new(n, 0)
  in_time = Array.new(n, 0)
  out_time = Array.new(n, 0)
  time = 0
  
  # is a ancestor of d, in time of d is in range of (in, out) time of a
  is_ancestor=->(a, d) { in_time[d] > in_time[a] && in_time[d] < out_time[a] }
  
  # calc subtree xor, and record in-out times
  # time, has to be kept outside, and tracked globally
  dfs=->(node, parent) {
    subtree_xor[node] = nums[node]
    in_time[node] = time
    time+=1
    
    graph[node].each do |neighbor|
      next if neighbor == parent
      dfs.call(neighbor, node)
      subtree_xor[node] ^= subtree_xor[neighbor]
    end
    
    out_time[node] = time
  }
  
  dfs.call(0, -1) # root at 0

  total_xor = subtree_xor[0]
  min_score = Float::INFINITY

  # Iterate through all pairs of nodes (i, j) to represent the two cuts.
  # The cuts are the edges between i/j and their parents.
  # We start from 1 because node 0 is the root and has no parent edge to cut above it.
  (1...n).each do |i|
    ((i+1)...n).each do |j|
      xor_i = subtree_xor[i]
      xor_j = subtree_xor[j]

      # Case: j is within i's subtree
      if is_ancestor.call(i, j)
        x1 = xor_j
        x2 = xor_i ^ xor_j
        x3 = total_xor ^ xor_i
      
      # Case: i is within j's subtree
      elsif is_ancestor.call(j, i)
        x1 = xor_i
        x2 = xor_j ^ xor_i
        x3 = total_xor ^ xor_j
      
      # Case: both are independent
      else
        x1 = xor_i
        x2 = xor_j
        x3 = total_xor ^ xor_i ^ xor_j
      end

      score = [x1, x2, x3].max - [x1, x2, x3].min
      min_score = [min_score, score].min
    end
  end
  
  min_score
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>