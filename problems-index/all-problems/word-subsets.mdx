---
title: 'ðŸ§€ Word Subsets'
description: '[leetcode link](https://leetcode.com/problems/word-subsets/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given two string arrays <code>words1</code> and <code>words2</code>.</p>  <p>A string <code>b</code> is a <strong>subset</strong> of string <code>a</code> if every letter in <code>b</code> occurs in <code>a</code> including multiplicity.</p>  <ul>  <li>For example, <code>&quot;wrr&quot;</code> is a subset of <code>&quot;warrior&quot;</code> but is not a subset of <code>&quot;world&quot;</code>.</li> </ul>  <p>A string <code>a</code> from <code>words1</code> is <strong>universal</strong> if for every string <code>b</code> in <code>words2</code>, <code>b</code> is a subset of <code>a</code>.</p>  <p>Return an array of all the <strong>universal</strong> strings in <code>words1</code>. You may return the answer in <strong>any order</strong>.</p>   <p><strong class="example">Example 1:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">words1 = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], words2 = [&quot;e&quot;,&quot;o&quot;]</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">[&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;]</span></p> </div>  <p><strong class="example">Example 2:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">words1 = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], words2 = [&quot;lc&quot;,&quot;eo&quot;]</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">[&quot;leetcode&quot;]</span></p> </div>  <p><strong class="example">Example 3:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">words1 = [&quot;acaac&quot;,&quot;cccbb&quot;,&quot;aacbb&quot;,&quot;caacc&quot;,&quot;bcbbb&quot;], words2 = [&quot;c&quot;,&quot;cc&quot;,&quot;b&quot;]</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">[&quot;cccbb&quot;]</span></p> </div>   <p><strong>Constraints:</strong></p>  <ul>  <li><code>1 &lt;= words1.length, words2.length &lt;= 10<sup>4</sup></code></li>  <li><code>1 &lt;= words1[i].length, words2[i].length &lt;= 10</code></li>  <li><code>words1[i]</code> and <code>words2[i]</code> consist only of lowercase English letters.</li>  <li>All the strings of <code>words1</code> are <strong>unique</strong>.</li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      For a word to be universal it should have all the chars and enough chars from words2 array. To calculate the requirement pick max char count for each char for each word in words2. All the words in words1 which satisfy the requirement are universal.
    </Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Word Subsets" lines
# @param {String[]} words1
# @param {String[]} words2
# @return {String[]}
def word_subsets(words1, words2)
  char_count_requirements = Hash.new(0)
  words2.each do |word|
    word.chars.tally.each do |ch, count|
      char_count_requirements[ch] = [char_count_requirements[ch], count].max
    end
  end

  words1.select do |word|
    ch_tally = word.chars.tally
    char_count_requirements.all? { |ch, count| ch_tally[ch].to_i >= count }
  end
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>