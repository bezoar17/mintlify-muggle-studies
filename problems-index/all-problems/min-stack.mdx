---
title: "ðŸ§€ Min Stack"
description: '[leetcode link](https://leetcode.com/problems/min-stack/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>  <p>Implement the <code>MinStack</code> class:</p>  <ul>  <li><code>MinStack()</code> initializes the stack object.</li>  <li><code>void push(int val)</code> pushes the element <code>val</code> onto the stack.</li>  <li><code>void pop()</code> removes the element on the top of the stack.</li>  <li><code>int top()</code> gets the top element of the stack.</li>  <li><code>int getMin()</code> retrieves the minimum element in the stack.</li> </ul>  <p>You must implement a solution with <code>O(1)</code> time complexity for each function.</p>   <p><strong class="example">Example 1:</strong></p>   <strong>Input</strong> [&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;] [[],[-2],[0],[-3],[],[],[],[]]  <strong>Output</strong> [null,null,null,null,-3,null,0,-2]  <strong>Explanation</strong> MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); // return -3 minStack.pop(); minStack.top();    // return 0 minStack.getMin(); // return -2    <p><strong>Constraints:</strong></p>  <ul>  <li><code>-2<sup>31</sup> &lt;= val &lt;= 2<sup>31</sup> - 1</code></li>  <li>Methods <code>pop</code>, <code>top</code> and <code>getMin</code> operations will always be called on <strong>non-empty</strong> stacks.</li>  <li>At most <code>3 * 10<sup>4</sup></code> calls will be made to <code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>.</li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      When new no. is added, current min is updated, we know that. But when min is popped, what is the new min ? we dont want to calculate it for all the remaining no.s on the stack. But we can store the min along with the number when a number is added. So, after a removal, the top element has the minimum that was present for that state of the stack.
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Min Stack" lines
class MinStack
    def initialize()
      @arr = []
    end


=begin
    :type val: Integer
    :rtype: Void
=end
    def push(val)
      @arr << [val, [@arr.last&.last || val, val].min]
    end


=begin
    :rtype: Void
=end
    def pop()
      @arr.pop
    end


=begin
    :rtype: Integer
=end
    def top()
      @arr.last.first
    end


=begin
    :rtype: Integer
=end
    def get_min()
      @arr.last.last  
    end


end

# Your MinStack object will be instantiated and called as such:
# obj = MinStack.new()
# obj.push(val)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.get_min()
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>