---
title: "❗️ Minimize Malware Spread II"
description: '[leetcode link](https://leetcode.com/problems/minimize-malware-spread-ii/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given a network of <code>n</code> nodes represented as an <code>n x n</code> adjacency matrix <code>graph</code>, where the <code>i<sup>th</sup></code> node is directly connected to the <code>j<sup>th</sup></code> node if <code>graph[i][j] == 1</code>.</p>  <p>Some nodes <code>initial</code> are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.</p>  <p>Suppose <code>M(initial)</code> is the final number of nodes infected with malware in the entire network after the spread of malware stops.</p>  <p>We will remove <strong>exactly one node</strong> from <code>initial</code>, <strong>completely removing it and any connections from this node to any other node</strong>.</p>  <p>Return the node that, if removed, would minimize <code>M(initial)</code>. If multiple nodes could be removed to minimize <code>M(initial)</code>, return such a node with <strong>the smallest index</strong>.</p>   <p><strong class="example">Example 1:</strong></p> <strong>Input:</strong> graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] <br/> <strong>Output:</strong> 0 <p><strong class="example">Example 2:</strong></p> <strong>Input:</strong> graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1] <br/> <strong>Output:</strong> 1 <p><strong class="example">Example 3:</strong></p> <strong>Input:</strong> graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1] <br/> <strong>Output:</strong> 1   <p><strong>Constraints:</strong></p>  <ul>  <li><code>n == graph.length</code></li>  <li><code>n == graph[i].length</code></li>  <li><code>2 &lt;= n &lt;= 300</code></li>  <li><code>graph[i][j]</code> is <code>0</code> or <code>1</code>.</li>  <li><code>graph[i][j] == graph[j][i]</code></li>  <li><code>graph[i][i] == 1</code></li>  <li><code>1 &lt;= initial.length &lt;&nbsp;n</code></li>  <li><code>0 &lt;= initial[i] &lt;= n - 1</code></li>  <li>All the integers in <code>initial</code> are <strong>unique</strong>.</li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Similar to https://leetcode.com/problems/minimize-malware-spread/. 
Here the components we make are first without any node from initial. Suppose this is C1, C2, C3 etc. For each initial node, check its edges to see which components it will affect if its edges are used, suppose C1 is affected by I1 and I2, then in either I1 or I2 nodes, C1 is not counted. Only components which are uniquely affected are counted. Here as opposed to the first version of the problem, component size changes upon deactivation of the intial malware nodes. Hence, we calculate component sizes first without the intial nodes itself, and then process the components. 

1 initial node can singularly affect multiple components, so we take sizes of all components in consideration.
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Minimize Malware Spread II" lines
# @param {Integer[][]} graph
# @param {Integer[]} initial
# @return {Integer}
class UnionFind
  attr_accessor :nodes, :sizes
  attr_reader :max_set_size

  def initialize(node_keys=[])
    @nodes = {}
    @sizes = {}
    @max_set_size = 0
    node_keys.each { |i| root(i) }
  end

  # this will create a node key if it doesnt exist
  def root(i)
    nodes[i] ||= i; sizes[i] ||= 1; # create node if it doesnt exist

    while nodes[i] != i
      nodes[i] = nodes[nodes[i]] # path compression
      i = nodes[i]
    end
    i
  end

  def size_for(i)
    sizes[root(i)]
  end

  def union(i, j)
    root_of_i = root(i)
    root_of_j = root(j)

    return false if root_of_i == root_of_j

    if sizes[root_of_j] > sizes[root_of_i]
      nodes[root_of_i] = root_of_j
      sizes[root_of_j] += sizes[root_of_i]
    else
      nodes[root_of_j] = root_of_i
      sizes[root_of_i] += sizes[root_of_j]
    end
    @max_set_size = [@max_set_size, sizes[root_of_i], sizes[root_of_j]].max
  end
end

def min_malware_spread(graph, initial)
  uf = UnionFind.new
  n = graph.size
  initial_set = initial.to_set
  (0...n).each {|i| (0...n).each {|j| uf.union(i,j) if graph[i][j] == 1 && i!=j && !initial_set.include?(i) && !initial_set.include?(j)} }

  # store for a component, which initial_nodes affect it
  component_risk_count = (0...n).select {|i| uf.root(i)==i }.map{|i| [i,Set.new] }.to_h
  
  initial.each do |infected_node|
    (0...n).each do |neighbor|
      next if graph[infected_node][neighbor] == 0 || initial_set.include?(neighbor)
      component_risk_count[uf.root(neighbor)] << infected_node
    end
  end

  initial_affected_sum = Hash.new(0) # sum of all component sizes which are singularly affected by initial node
  component_risk_count.each {|c,i_set| initial_affected_sum[i_set.first]+=uf.sizes[c] if i_set.size==1 }
  initial.sort_by {|i| [-initial_affected_sum[i],i] }.first
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>