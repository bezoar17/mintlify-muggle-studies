---
title: "❗️ Delete Duplicate Folders in System"
description: '[leetcode link](https://leetcode.com/problems/delete-duplicate-folders-in-system/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>Due to a bug, there are many duplicate folders in a file system. You are given a 2D array <code>paths</code>, where <code>paths[i]</code> is an array representing an absolute path to the <code>i<sup>th</sup></code> folder in the file system.</p>  <ul>  <li>For example, <code>[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</code> represents the path <code>&quot;/one/two/three&quot;</code>.</li> </ul>  <p>Two folders (not necessarily on the same level) are <strong>identical</strong> if they contain the <strong>same non-empty</strong> set of identical subfolders and underlying subfolder structure. The folders <strong>do not</strong> need to be at the root level to be identical. If two or more folders are <strong>identical</strong>, then <strong>mark</strong> the folders as well as all their subfolders.</p>  <ul>  <li>For example, folders <code>&quot;/a&quot;</code> and <code>&quot;/b&quot;</code> in the file structure below are identical. They (as well as their subfolders) should <strong>all</strong> be marked:   <ul>   <li><code>/a</code></li>   <li><code>/a/x</code></li>   <li><code>/a/x/y</code></li>   <li><code>/a/z</code></li>   <li><code>/b</code></li>   <li><code>/b/x</code></li>   <li><code>/b/x/y</code></li>   <li><code>/b/z</code></li>  </ul>  </li>  <li>However, if the file structure also included the path <code>&quot;/b/w&quot;</code>, then the folders <code>&quot;/a&quot;</code> and <code>&quot;/b&quot;</code> would not be identical. Note that <code>&quot;/a/x&quot;</code> and <code>&quot;/b/x&quot;</code> would still be considered identical even with the added folder.</li> </ul>  <p>Once all the identical folders and their subfolders have been marked, the file system will <strong>delete</strong> all of them. The file system only runs the deletion once, so any folders that become identical after the initial deletion are not deleted.</p>  <p>Return <em>the 2D array </em><code>ans</code> <em>containing the paths of the <strong>remaining</strong> folders after deleting all the marked folders. The paths may be returned in <strong>any</strong> order</em>.</p>   <p><strong class="example">Example 1:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder1.jpg" style="width: 200px; height: 218px;" />  <strong>Input:</strong> paths = [[&quot;a&quot;],[&quot;c&quot;],[&quot;d&quot;],[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;d&quot;,&quot;a&quot;]] <br/> <strong>Output:</strong> [[&quot;d&quot;],[&quot;d&quot;,&quot;a&quot;]] <br/> <strong>Explanation:</strong> The file structure is as shown. Folders &quot;/a&quot; and &quot;/c&quot; (and their subfolders) are marked for deletion because they both contain an empty folder named &quot;b&quot;.   <p><strong class="example">Example 2:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder2.jpg" style="width: 200px; height: 355px;" />  <strong>Input:</strong> paths = [[&quot;a&quot;],[&quot;c&quot;],[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;x&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;x&quot;,&quot;y&quot;],[&quot;w&quot;],[&quot;w&quot;,&quot;y&quot;]] <br/> <strong>Output:</strong> [[&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;a&quot;],[&quot;a&quot;,&quot;b&quot;]] <strong>Explanation: </strong>The file structure is as shown.  Folders &quot;/a/b/x&quot; and &quot;/w&quot; (and their subfolders) are marked for deletion because they both contain an empty folder named &quot;y&quot;. Note that folders &quot;/a&quot; and &quot;/c&quot; are identical after the deletion, but they are not deleted because they were not marked beforehand.   <p><strong class="example">Example 3:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder3.jpg" style="width: 200px; height: 201px;" />  <strong>Input:</strong> paths = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;],[&quot;c&quot;],[&quot;a&quot;]] <br/> <strong>Output:</strong> [[&quot;c&quot;],[&quot;c&quot;,&quot;d&quot;],[&quot;a&quot;],[&quot;a&quot;,&quot;b&quot;]] <br/> <strong>Explanation:</strong> All folders are unique in the file system. Note that the returned array can be in a different order as the order does not matter.    <p><strong>Constraints:</strong></p>  <ul>  <li><code>1 &lt;= paths.length &lt;= 2 * 10<sup>4</sup></code></li>  <li><code>1 &lt;= paths[i].length &lt;= 500</code></li>  <li><code>1 &lt;= paths[i][j].length &lt;= 10</code></li>  <li><code>1 &lt;= sum(paths[i][j].length) &lt;= 2 * 10<sup>5</sup></code></li>  <li><code>path[i][j]</code> consists of lowercase English letters.</li>  <li>No two paths lead to the same folder.</li>  <li>For any folder not at the root level, its parent folder will also be in the input.</li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      For any folder not at the root level, its parent folder will also be in the input.
so we can just build the trie using this first

a particular sub-tree has same structure, then parent of both should be marked for deletion.
get a way to serialize a tree, and record the subtrees.
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Delete Duplicate Folders in System" lines
# @param {String[][]} paths
# @return {String[][]}

class Node
  attr_accessor :children, :to_be_deleted
  def initialize
    @children = {}
    @to_be_deleted = false
  end
end

def delete_duplicate_folder(paths)
  root = Node.new
  seen = Hash.new {|h,k| h[k]=[]}

  # build the tree
  paths.each do |path|
    node = root
    path.each do |folder|
      node.children[folder] = Node.new unless node.children.include?(folder)
      node = node.children[folder]
    end
  end

  # serialize sub-trees and record nodes against it
  dfs=->(node) {
    return '' if node.children.empty?
    
    # ensure children names are ordered, they might have been inserted in diff orders
    serialized_subtree = node.children.keys.sort.map do |child|
      "#{child}(#{dfs.call(node.children[child])})"
    end.join
    
    seen[serialized_subtree] << node
    serialized_subtree
  }

  dfs.call(root)

  # Mark nodes for deletion
  seen.values.select {|v| v.size > 1}.each { |nodes| nodes.each {|node| node.to_be_deleted = true } }

  # Collect all paths which are non-deleted
  result = []

  collect=->(node, path) {
    node.children.each do |name, child_node|
      next if child_node.to_be_deleted
      result.append(path + [name])
      collect.call(child_node, path + [name])
    end
  }

  collect.call(root, [])
  result
end

```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>