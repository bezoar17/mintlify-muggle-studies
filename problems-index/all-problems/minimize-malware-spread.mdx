---
title: "❗️ Minimize Malware Spread"
description: '[leetcode link](https://leetcode.com/problems/minimize-malware-spread/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given a network of <code>n</code> nodes represented as an <code>n x n</code> adjacency matrix <code>graph</code>, where the <code>i<sup>th</sup></code> node is directly connected to the <code>j<sup>th</sup></code> node if <code>graph[i][j] == 1</code>.</p>  <p>Some nodes <code>initial</code> are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.</p>  <p>Suppose <code>M(initial)</code> is the final number of nodes infected with malware in the entire network after the spread of malware stops. We will remove <strong>exactly one node</strong> from <code>initial</code>.</p>  <p>Return the node that, if removed, would minimize <code>M(initial)</code>. If multiple nodes could be removed to minimize <code>M(initial)</code>, return such a node with <strong>the smallest index</strong>.</p>  <p>Note that if a node was removed from the <code>initial</code> list of infected nodes, it might still be infected later due to the malware spread.</p>   <p><strong class="example">Example 1:</strong></p> <strong>Input:</strong> graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] <br/> <strong>Output:</strong> 0 <p><strong class="example">Example 2:</strong></p> <strong>Input:</strong> graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2] <br/> <strong>Output:</strong> 0 <p><strong class="example">Example 3:</strong></p> <strong>Input:</strong> graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2] <br/> <strong>Output:</strong> 1   <p><strong>Constraints:</strong></p>  <ul>  <li><code>n == graph.length</code></li>  <li><code>n == graph[i].length</code></li>  <li><code>2 &lt;= n &lt;= 300</code></li>  <li><code>graph[i][j]</code> is <code>0</code> or <code>1</code>.</li>  <li><code>graph[i][j] == graph[j][i]</code></li>  <li><code>graph[i][i] == 1</code></li>  <li><code>1 &lt;= initial.length &lt;= n</code></li>  <li><code>0 &lt;= initial[i] &lt;= n - 1</code></li>  <li>All the integers in <code>initial</code> are <strong>unique</strong>.</li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Graph is composed of multiple connected components. If a component has more than 1 infected node, removing any of these infected nodes will not improve the situation for this component, all within this component will be affected. So, we have to find components with only 1 infected node. Removing this one, will fix all nodes in this component. So, find component with 1 infected node and has the max size, that is the answer.
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Minimize Malware Spread" lines
# @param {Integer[][]} graph
# @param {Integer[]} initial
# @return {Integer}
class UnionFind
  attr_accessor :nodes, :sizes
  attr_reader :max_set_size

  def initialize(node_keys=[])
    @nodes = {}
    @sizes = {}
    @max_set_size = 0
    node_keys.each { |i| root(i) }
  end

  # this will create a node key if it doesnt exist
  def root(i)
    nodes[i] ||= i; sizes[i] ||= 1; # create node if it doesnt exist

    while nodes[i] != i
      nodes[i] = nodes[nodes[i]] # path compression
      i = nodes[i]
    end
    i
  end

  def size_for(i)
    sizes[root(i)]
  end

  def union(i, j)
    root_of_i = root(i)
    root_of_j = root(j)

    return false if root_of_i == root_of_j

    if sizes[root_of_j] > sizes[root_of_i]
      nodes[root_of_i] = root_of_j
      sizes[root_of_j] += sizes[root_of_i]
    else
      nodes[root_of_j] = root_of_i
      sizes[root_of_i] += sizes[root_of_j]
    end
    @max_set_size = [@max_set_size, sizes[root_of_i], sizes[root_of_j]].max
  end
end

def min_malware_spread(graph, initial)
  uf = UnionFind.new
  n = graph.size
  (0...n).each {|x| uf.root(x)}
  (0...n).each {|i| (0...n).each {|j| uf.union(i,j) if graph[i][j] == 1 && i!=j } }

  single_infected_roots = initial.map { |x| uf.root(x) }.tally.select {|k,v| v==1 }.map(&:first).to_set
  return initial.min if single_infected_roots.empty?

  initial.select { |x| single_infected_roots.include?(uf.root(x)) }.sort_by{|x| [uf.sizes[uf.root(x)], -x] }.last
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>