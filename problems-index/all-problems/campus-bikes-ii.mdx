---
title: "ðŸ§€ Campus Bikes II"
description: '[leetcode link](https://leetcode.com/problems/campus-bikes-ii/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>On a campus represented as a 2D grid, there are <code>n</code> workers and <code>m</code> bikes, with <code>n &lt;= m</code>. Each worker and bike is a 2D coordinate on this grid.</p>  <p>We assign one unique bike to each worker so that the sum of the <strong>Manhattan distances</strong> between each worker and their assigned bike is minimized.</p>  <p>Return <code>the minimum possible sum of Manhattan distances between each worker and their assigned bike</code>.</p>  <p>The <strong>Manhattan distance</strong> between two points <code>p1</code> and <code>p2</code> is <code>Manhattan(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|</code>.</p>   <p><strong class="example">Example 1:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2019/03/06/1261_example_1_v2.png" style="width: 376px; height: 366px;" />  <strong>Input:</strong> workers = [[0,0],[2,1]], bikes = [[1,2],[3,3]] <br/> <strong>Output:</strong> 6 <br/> <strong>Explanation:</strong>  We assign bike 0 to worker 0, bike 1 to worker 1. The Manhattan distance of both assignments is 3, so the output is 6.   <p><strong class="example">Example 2:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2019/03/06/1261_example_2_v2.png" style="width: 376px; height: 366px;" />  <strong>Input:</strong> workers = [[0,0],[1,1],[2,0]], bikes = [[1,0],[2,2],[2,1]] <br/> <strong>Output:</strong> 4 <strong>Explanation: </strong> We first assign bike 0 to worker 0, then assign bike 1 to worker 1 or worker 2, bike 2 to worker 2 or worker 1. Both assignments lead to sum of the Manhattan distances as 4.   <p><strong class="example">Example 3:</strong></p>   <strong>Input:</strong> workers = [[0,0],[1,0],[2,0],[3,0],[4,0]], bikes = [[0,999],[1,999],[2,999],[3,999],[4,999]] <br/> <strong>Output:</strong> 4995    <p><strong>Constraints:</strong></p>  <ul>  <li><code>n == workers.length</code></li>  <li><code>m == bikes.length</code></li>  <li><code>1 &lt;= n &lt;= m &lt;= 10</code></li>  <li><code>workers[i].length == 2</code></li>  <li><code>bikes[i].length == 2</code></li>  <li><code>0 &lt;= workers[i][0], workers[i][1], bikes[i][0], bikes[i][1] &lt; 1000</code></li>  <li>All the workers and the bikes locations are <strong>unique</strong>.</li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Manhattan(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|
If we try all possibilites, mCn, then, n! is total possibilities, n can be 10. So, this can become huge.

We can represent workers as mask, with 1 meaning they have a bike, 0 meaning they dont have a bike.
Instead of bikes as a mask, because m is &lt;=n. Now, if we calculate say 00010, bike assignment to 2nd worker, and store minimum we can get. We'll also have to store which bike it was. And, this local minimum, might not give us global minimum. So, we process all bikes, and for each bike, we process all masks, we can improve the dp, if this bikes assignment to any of the available workers will improve the score.
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Campus Bikes II" lines
# @param {Integer[][]} workers
# @param {Integer[][]} bikes
# @return {Integer}
def assign_bikes(workers, bikes)
  n = workers.size; m = bikes.size
  max_mask = 1<<n

  dp = Array.new(max_mask, Float::INFINITY)
  dp[0]=0
  dist=->(a,b) { (a[0] -b[0]).abs + (a[1] -b[1]).abs }
  
  bikes.each do |bike|
    dp_new = dp.dup
    (0...max_mask).each do |assignment|
      (0...n).each do |w|
        if assignment & (1<<w) > 0
          dp_new[assignment] = [dp[assignment ^ 1<<w]+dist[workers[w],bike], dp_new[assignment]].min
        end
      end
    end
    dp = dp_new
  end
  
  dp[max_mask-1]
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>