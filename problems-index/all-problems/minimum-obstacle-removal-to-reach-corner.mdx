---
title: "❗️ Minimum Obstacle Removal to Reach Corner"
description: '[leetcode link](https://leetcode.com/problems/minimum-obstacle-removal-to-reach-corner/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given a <strong>0-indexed</strong> 2D integer array <code>grid</code> of size <code>m x n</code>. Each cell has one of two values:</p>  <ul>  <li><code>0</code> represents an <strong>empty</strong> cell,</li>  <li><code>1</code> represents an <strong>obstacle</strong> that may be removed.</li> </ul>  <p>You can move up, down, left, or right from and to an empty cell.</p>  <p>Return <em>the <strong>minimum</strong> number of <strong>obstacles</strong> to <strong>remove</strong> so you can move from the upper left corner </em><code>(0, 0)</code><em> to the lower right corner </em><code>(m - 1, n - 1)</code>.</p>   <p><strong class="example">Example 1:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2022/04/06/example1drawio-1.png" style="width: 605px; height: 246px;" />  <strong>Input:</strong> grid = [[0,1,1],[1,1,0],[1,1,0]] <br/> <strong>Output:</strong> 2 <br/> <strong>Explanation:</strong> We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2). It can be shown that we need to remove at least 2 obstacles, so we return 2. Note that there may be other ways to remove 2 obstacles to create a path.   <p><strong class="example">Example 2:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2022/04/06/example1drawio.png" style="width: 405px; height: 246px;" />  <strong>Input:</strong> grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]] <br/> <strong>Output:</strong> 0 <br/> <strong>Explanation:</strong> We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0.    <p><strong>Constraints:</strong></p>  <ul>  <li><code>m == grid.length</code></li>  <li><code>n == grid[i].length</code></li>  <li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>  <li><code>2 &lt;= m * n &lt;= 10<sup>5</sup></code></li>  <li><code>grid[i][j]</code> is either <code>0</code> <strong>or</strong> <code>1</code>.</li>  <li><code>grid[0][0] == grid[m - 1][n - 1] == 0</code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      https://leetcode.com/problems/shortest-bridge/description/ 

If we flip the 0 and 1s, problem is same as above, but in this one, there can be more than 1 islands, we have to reach the 1 which has the target. Starting island is also fixed, one which contains 0,0.

So, whenever we find island, we traverse and mark it as visited, and then process other obstacles, we will only reach last island from an obstacle.

The Ruby tle, and python tle code we have written which does dfs, also processes all nodes once only. No node is processed if it is already visited.

But with function, it times out. 

From editorial, 
If we use deque, and keep all island at starting, and all obstacles at the end, in increasing order, d, d+1 etc, then also, and always process from the start, we will ensure we will always process all connected island nodes at once, similar to dfs but here no func etc would be required, hence it will be faster
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Minimum Obstacle Removal to Reach Corner" lines
# @param {Integer[][]} grid
# @return {Integer}
def minimum_obstacles(grid)
  m = grid.size
  n = grid[0].size
  deque = [[0, 0, 0]]
  visited = Array.new(m) { Array.new(n, false) }
  visited[0][0] = true
  directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]

  until deque.empty?
    x, y, cost = deque.shift
    return cost if x == m - 1 && y == n - 1

    directions.each do |dx, dy|
      nx = x + dx
      ny = y + dy
      next if !nx.between?(0,m-1) || !ny.between?(0,n-1) || visited[nx][ny]

      visited[nx][ny] = true

      if grid[nx][ny] == 0
        deque.unshift([nx, ny, cost])
      else
        deque.push([nx, ny, cost + 1])
      end
    end
  end
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>