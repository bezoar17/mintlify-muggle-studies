---
title: 'ðŸ§€ Find Minimum Time to Reach Last Room II'
description: '[leetcode link](https://leetcode.com/problems/find-minimum-time-to-reach-last-room-ii/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>There is a dungeon with <code>n x m</code> rooms arranged as a grid.</p>  <p>You are given a 2D array <code>moveTime</code> of size <code>n x m</code>, where <code>moveTime[i][j]</code> represents the <strong>minimum</strong> time in seconds when you can <strong>start moving</strong> to that room. You start from the room <code>(0, 0)</code> at time <code>t = 0</code> and can move to an <strong>adjacent</strong> room. Moving between <strong>adjacent</strong> rooms takes one second for one move and two seconds for the next, <strong>alternating</strong> between the two.</p>  <p>Return the <strong>minimum</strong> time to reach the room <code>(n - 1, m - 1)</code>.</p>  <p>Two rooms are <strong>adjacent</strong> if they share a common wall, either <em>horizontally</em> or <em>vertically</em>.</p>   <p><strong class="example">Example 1:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">moveTime = [[0,4],[4,4]]</span></p>  <p><br/> <strong>Output:</strong> 7</p>  <p><br/> <strong>Explanation:</strong></p>  <p>The minimum time required is 7 seconds.</p>  <ul>  <li>At time <code>t == 4</code>, move from room <code>(0, 0)</code> to room <code>(1, 0)</code> in one second.</li>  <li>At time <code>t == 5</code>, move from room <code>(1, 0)</code> to room <code>(1, 1)</code> in two seconds.</li> </ul> </div>  <p><strong class="example">Example 2:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">moveTime = [[0,0,0,0],[0,0,0,0]]</span></p>  <p><br/> <strong>Output:</strong> 6</p>  <p><br/> <strong>Explanation:</strong></p>  <p>The minimum time required is 6 seconds.</p>  <ul>  <li>At time <code>t == 0</code>, move from room <code>(0, 0)</code> to room <code>(1, 0)</code> in one second.</li>  <li>At time <code>t == 1</code>, move from room <code>(1, 0)</code> to room <code>(1, 1)</code> in two seconds.</li>  <li>At time <code>t == 3</code>, move from room <code>(1, 1)</code> to room <code>(1, 2)</code> in one second.</li>  <li>At time <code>t == 4</code>, move from room <code>(1, 2)</code> to room <code>(1, 3)</code> in two seconds.</li> </ul> </div>  <p><strong class="example">Example 3:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">moveTime = [[0,1],[1,2]]</span></p>  <p><br/> <strong>Output:</strong> 4</p> </div>   <p><strong>Constraints:</strong></p>  <ul>  <li><code>2 &lt;= n == moveTime.length &lt;= 750</code></li>  <li><code>2 &lt;= m == moveTime[i].length &lt;= 750</code></li>  <li><code>0 &lt;= moveTime[i][j] &lt;= 10<sup>9</sup></code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Same as 1 version of the problem, but also keep track of the last step taken in the path and djikstra's pq.
Ruby pq gives, TLE, python works.
    </Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```python3 title="Find Minimum Time to Reach Last Room II" lines
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        dist = [[None] * m for _ in range(n)]
        
        # Priority queue: (current_time, (i, j), last_time_taken)
        pq = [(0, (0, 0), 2)]
        
        def get_neighbors(x: int, y: int) -> List[tuple]:
            directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]
            neighbors = []
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if (0 <= nx < n and 
                    0 <= ny < m and 
                    dist[nx][ny] is None):
                    neighbors.append((nx, ny))
            return neighbors
        
        while pq:
            curr_time, (i, j), last_time_taken = heappop(pq)
            
            # Skip if already visited
            if dist[i][j] is not None:
                continue
                
            # Mark as visited
            dist[i][j] = curr_time
            
            # Check if reached destination
            if i == n-1 and j == m-1:
                return curr_time
            
            # Process neighbors
            for ni, nj in get_neighbors(i, j):
                time_taken_for_this_move = 3 - last_time_taken
                neighbor_time = time_taken_for_this_move + max(curr_time, moveTime[ni][nj])
                heappush(pq, (neighbor_time, (ni, nj), time_taken_for_this_move))
                
        return -1  # In case destination is unreachable
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>