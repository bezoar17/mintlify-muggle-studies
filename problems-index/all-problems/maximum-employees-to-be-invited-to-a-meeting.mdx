---
title: '❗️ Maximum Employees to Be Invited to a Meeting'
description: '[leetcode link](https://leetcode.com/problems/maximum-employees-to-be-invited-to-a-meeting/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>A company is organizing a meeting and has a list of <code>n</code> employees, waiting to be invited. They have arranged for a large <strong>circular</strong> table, capable of seating <strong>any number</strong> of employees.</p>  <p>The employees are numbered from <code>0</code> to <code>n - 1</code>. Each employee has a <strong>favorite</strong> person and they will attend the meeting <strong>only if</strong> they can sit next to their favorite person at the table. The favorite person of an employee is <strong>not</strong> themself.</p>  <p>Given a <strong>0-indexed</strong> integer array <code>favorite</code>, where <code>favorite[i]</code> denotes the favorite person of the <code>i<sup>th</sup></code> employee, return <em>the <strong>maximum number of employees</strong> that can be invited to the meeting</em>.</p>   <p><strong class="example">Example 1:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2021/12/14/ex1.png" style="width: 236px; height: 195px;" />  <strong>Input:</strong> favorite = [2,2,1,2] <br/> <strong>Output:</strong> 3 <br/> <strong>Explanation:</strong> The above figure shows how the company can invite employees 0, 1, and 2, and seat them at the round table. All employees cannot be invited because employee 2 cannot sit beside employees 0, 1, and 3, simultaneously. Note that the company can also invite employees 1, 2, and 3, and give them their desired seats. The maximum number of employees that can be invited to the meeting is 3.    <p><strong class="example">Example 2:</strong></p>   <strong>Input:</strong> favorite = [1,2,0] <br/> <strong>Output:</strong> 3 <br/> <strong>Explanation:</strong>  Each employee is the favorite person of at least one other employee, and the only way the company can invite them is if they invite every employee. The seating arrangement will be the same as that in the figure given in example 1: - Employee 0 will sit between employees 2 and 1. - Employee 1 will sit between employees 0 and 2. - Employee 2 will sit between employees 1 and 0. The maximum number of employees that can be invited to the meeting is 3.   <p><strong class="example">Example 3:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2021/12/14/ex2.png" style="width: 219px; height: 220px;" />  <strong>Input:</strong> favorite = [3,0,1,4,1] <br/> <strong>Output:</strong> 4 <br/> <strong>Explanation:</strong> The above figure shows how the company will invite employees 0, 1, 3, and 4, and seat them at the round table. Employee 2 cannot be invited because the two spots next to their favorite employee 1 are taken. So the company leaves them out of the meeting. The maximum number of employees that can be invited to the meeting is 4.    <p><strong>Constraints:</strong></p>  <ul>  <li><code>n == favorite.length</code></li>  <li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>  <li><code>0 &lt;= favorite[i] &lt;=&nbsp;n - 1</code></li>  <li><code>favorite[i] != i</code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Group of friends, besties and wannabees.

Group of friend - Cycle of size &gt; 2.
Besties -&gt; Cycle of size 2
Wannabees -&gt; Acyclic chain ending at either end of bestie pair.

Final seating can be, (1 group of friends) OR (all besties and their wannabees)

One of the case of max is n, when favorite[i]=i+1 or i-1 and cycles over at the last element.
Suppose we make a graph where there is an edge from i -&gt; favorite[i], indicating i requires favourite[i] to be seated next to i.

When can answer be n ?
Case 1 we have a cycle of n
Case 2 maybe n is even, and we have n/2 pairs of best friends(both want to sit next to each other).
There are other cases also, but these 2 cases give us some insight
Cycle of X cant accomodate anyone else. So if we have n cycles, we can pick one with max length.
In case of besties, i.e, cycle of 2 elements. Imagine a cycle where we need to make people sit. If we have 3 pairs of besties, we can ensure pairs are adjacent, but order of these pairs can be anything. Suppose 3 pairs are [a1,a2] [b1,b2] [c1,c2], people sitting are 6, but final order of these is not 1. This is not the case with cycle of size &gt; 2, we have only 1 order of size cycle_length.
  
&lt;a1 a2&gt; order is fixed, but what comes before of after this pair is not limited by anything.
So, we can take advantage of this to seat more people on their either side. But if there are 2 acyclic chains, 1 ending at a1, say AC1{ wb1-&gt;wb2-&gt;a1 } and 1 ending at a2 say, AC2{ wb3-&gt;wb4-&gt;a2 }
For these 2 chains, 1 end is fixed(a1 or a2), and we can combine them with &lt;a1 a2&gt; pair to form a longer chain of people which can be seated together. If we do this, we will still have freedom of movement of the 3 original bestie pair, but here &lt;a1 a2&gt; just brought more people with them.
Pairs &lt;b1 b2&gt; and &lt;c1 c2&gt;, are still independent, and can be seated, final chain can be [wb1 wb2 a1 a2 wb3 wb4] [b1 b2] [c1 c2]. The boundaries [] can be reordered still.
 Because of this,  all cycles of 2 can bring chains of people from either end of the pair.
 
 Obviously, there can be multiple chains from one end of the bestie pair, and well pick the max of it.
 
 This is the only other configuration apart from a cycle of size &gt; 2, which is valid.

So, answer becomes, MAX( max_cycle_length, people count of all besties and their chains)
  
To find the answer, we just find the cycles, cycle length can be 2 or more. When its 2 we do more compute for the all besties with chains configuration. To find the chains ending at either end of bestie pair, we can use a reversed graph, and start from each node of bestie pair.

This can be thought of as there being groups of people which can all sit together.
Cycle of &gt;2 are exclusive group, you cant add more people to it
For every cycle of 2, every bestie pair, each person of the pair has chain of wannabees which are not part of any group(acyclic chain ),  they just know 1 other person they want to go with which knows some other. person and so on, and last wannabe knows one of the besties. 

When there are more than 1 chain of wannabees, each person in bestie pair picks the most number of people they can bring to the event.


Now, to simplify the calculation, we can use Kahns algorithm. Here we wont need reverse graph.

Each person is part of acyclic chain ending at a cycle or part of a cycle themselves
So starting from each person, you start you will eventually reach a cycle

In Kahns algorithm, we start processing the acyclic chains first, and end before we enter the cycle. So we have processed all chains, and we can calculate the max_depth of the chain till a particular node as max of all chains ending at i. Suppose w1-&gt;w2-&gt;w3-&gt;a1. Depth of w1 will be 1, w2 1, w3 2 and a1 is 3.

If there was another chain x1-&gt;x2-&gt;x3-&gt;x4-&gt;w2-&gt;w3-&gt;a1. Depth of a1 should be 6. Which will be updated when due to the x1 traversal. So once we completed Kahns algorithm, we have processed all non-cycle nodes and we have the max_depth of each node, which is max wannabees a bestie can bring. We dont have to recalculate that. 

Now, for the remaining nodes/persons, all of them are part of some cycle, we just process those.




    </Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Maximum Employees to Be Invited to a Meeting" lines
# @param {Integer[]} favorite
# @return {Integer}
def maximum_invitations(favorite)
  n = favorite.size
  in_degree = Array.new(n, 0)
  favorite.each {|f| in_degree[f]+=1 }
  
  q = []
  in_degree.each_with_index {|idg, i| q<<i  if idg==0 }

  max_depth = Array.new(n, 0) # max length of acylic chain connected to i, hence initialzed as 0

  until q.empty?
    node = q.pop
    next_node = favorite[node]
    max_depth[next_node] = [max_depth[next_node], 1 + max_depth[node]].max
    in_degree[next_node] -= 1
    q << next_node if in_degree[next_node]==0
  end

  longest_cycle_of_friends = 0
  besties_and_wannabes = 0
  
  (0...n).each do |person|
    next if in_degree[person] == 0 # chains have been processed, now only cycles remains

    cycle_of_friends = 0
    current = person
    while in_degree[current] !=0
      in_degree[current] = 0 # mark as visited, also all elements in a cycle have idg=1.
      cycle_of_friends+=1
      current = favorite[current]
    end

    if cycle_of_friends == 2      # besties    + wannabees for B1  + wannabees for B2, B1's bestie
      besties_and_wannabes+=  cycle_of_friends + max_depth[person] + max_depth[favorite[person]]
    else
      longest_cycle_of_friends = [longest_cycle_of_friends, cycle_of_friends].max
    end
  end

  [longest_cycle_of_friends, besties_and_wannabes].max
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>