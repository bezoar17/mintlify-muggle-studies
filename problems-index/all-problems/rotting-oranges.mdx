---
title: "ðŸ§€ Rotting Oranges"
description: '[leetcode link](https://leetcode.com/problems/rotting-oranges/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given an <code>m x n</code> <code>grid</code> where each cell can have one of three values:</p>  <ul>  <li><code>0</code> representing an empty cell,</li>  <li><code>1</code> representing a fresh orange, or</li>  <li><code>2</code> representing a rotten orange.</li> </ul>  <p>Every minute, any fresh orange that is <strong>4-directionally adjacent</strong> to a rotten orange becomes rotten.</p>  <p>Return <em>the minimum number of minutes that must elapse until no cell has a fresh orange</em>. If <em>this is impossible, return</em> <code>-1</code>.</p>   <p><strong class="example">Example 1:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2019/02/16/oranges.png" style="width: 650px; height: 137px;" />  <strong>Input:</strong> grid = [[2,1,1],[1,1,0],[0,1,1]] <br/> <strong>Output:</strong> 4   <p><strong class="example">Example 2:</strong></p>   <strong>Input:</strong> grid = [[2,1,1],[0,1,1],[1,0,1]] <br/> <strong>Output:</strong> -1 <br/> <strong>Explanation:</strong> The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.   <p><strong class="example">Example 3:</strong></p>   <strong>Input:</strong> grid = [[0,2]] <br/> <strong>Output:</strong> 0 <br/> <strong>Explanation:</strong> Since there are already no fresh oranges at minute 0, the answer is just 0.    <p><strong>Constraints:</strong></p>  <ul>  <li><code>m == grid.length</code></li>  <li><code>n == grid[i].length</code></li>  <li><code>1 &lt;= m, n &lt;= 10</code></li>  <li><code>grid[i][j]</code> is <code>0</code>, <code>1</code>, or <code>2</code>.</li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Multi-source BFS from rotten oranges, distance is the time elapsed. Keep a counter of fresh oranges, when it reaches 0.
If bfs ends due to no more valid edges(adjacent oranges, i.e bfs queue becomes), and fresh oranges are still remaining, then those will never get affected, return -1.
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Rotting Oranges" lines
# @param {Integer[][]} grid
# @return {Integer}
def oranges_rotting(grid)
  qu = Queue.new
  m,n = grid.size, grid[0].size
  fresh_oranges = 0
  time = 0

  (0...m).to_a.each do |i|
    (0...n).to_a.each do |j|
      fresh_oranges+=1 if grid[i][j] == 1
      if grid[i][j] == 2
        qu.push([i,j])
      end
    end
  end

  directions = [[0,1], [0,-1], [1,0], [-1,0]]

  while !qu.empty? && fresh_oranges > 0

    queue_length = qu.size
    (1..queue_length).each do |k|
      x,y = qu.pop
      for i,j in directions do
        dx = x+i; dy = y+j;
        if dx.between?(0,m-1) && dy.between?(0,n-1) && grid[dx][dy] == 1
          grid[dx][dy] = 2
          qu.push([dx,dy])
          fresh_oranges-=1
        end
      end
    end
    time+=1
  end

  fresh_oranges == 0 ? time : -1
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>