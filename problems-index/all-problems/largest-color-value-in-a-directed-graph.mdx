---
title: "❗️ Largest Color Value in a Directed Graph"
description: '[leetcode link](https://leetcode.com/problems/largest-color-value-in-a-directed-graph/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>There is a <strong>directed graph</strong> of <code>n</code> colored nodes and <code>m</code> edges. The nodes are numbered from <code>0</code> to <code>n - 1</code>.</p>  <p>You are given a string <code>colors</code> where <code>colors[i]</code> is a lowercase English letter representing the <strong>color</strong> of the <code>i<sup>th</sup></code> node in this graph (<strong>0-indexed</strong>). You are also given a 2D array <code>edges</code> where <code>edges[j] = [a<sub>j</sub>, b<sub>j</sub>]</code> indicates that there is a <strong>directed edge</strong> from node <code>a<sub>j</sub></code> to node <code>b<sub>j</sub></code>.</p>  <p>A valid <strong>path</strong> in the graph is a sequence of nodes <code>x<sub>1</sub> -&gt; x<sub>2</sub> -&gt; x<sub>3</sub> -&gt; ... -&gt; x<sub>k</sub></code> such that there is a directed edge from <code>x<sub>i</sub></code> to <code>x<sub>i+1</sub></code> for every <code>1 &lt;= i &lt; k</code>. The <strong>color value</strong> of the path is the number of nodes that are colored the <strong>most frequently</strong> occurring color along that path.</p>  <p>Return <em>the <strong>largest color value</strong> of any valid path in the given graph, or </em><code>-1</code><em> if the graph contains a cycle</em>.</p>   <p><strong class="example">Example 1:</strong></p>  <p><img alt="" src="https://assets.leetcode.com/uploads/2021/04/21/leet1.png" style="width: 400px; height: 182px;" /></p>   <strong>Input:</strong> colors = &quot;abaca&quot;, edges = [[0,1],[0,2],[2,3],[3,4]] <br/> <strong>Output:</strong> 3 <br/> <strong>Explanation:</strong> The path 0 -&gt; 2 -&gt; 3 -&gt; 4 contains 3 nodes that are colored <code>&quot;a&quot; (red in the above image)</code>.   <p><strong class="example">Example 2:</strong></p>  <p><img alt="" src="https://assets.leetcode.com/uploads/2021/04/21/leet2.png" style="width: 85px; height: 85px;" /></p>   <strong>Input:</strong> colors = &quot;a&quot;, edges = [[0,0]] <br/> <strong>Output:</strong> -1 <br/> <strong>Explanation:</strong> There is a cycle from 0 to 0.    <p><strong>Constraints:</strong></p>  <ul>  <li><code>n == colors.length</code></li>  <li><code>m == edges.length</code></li>  <li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>  <li><code>0 &lt;= m &lt;= 10<sup>5</sup></code></li>  <li><code>colors</code> consists of lowercase English letters.</li>  <li><code>0 &lt;= a<sub>j</sub>, b<sub>j</sub>&nbsp;&lt; n</code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      DAG is a requirement. Start from nodes with in-degree=0, and process all nodes. This traversal will satisfy requirement of valid path. For each node, there will be some paths ending at this node, keep the char count for all chars in all the paths that end at this node. For each char's count, pick max count. Finally, for each node you will have max_char_count for each char. Pick the maximum value amongst these.
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Largest Color Value in a Directed Graph" lines
# @param {String} colors
# @param {Integer[][]} edges
# @return {Integer}
def largest_path_value(colors, edges)
  # just start from i-deg 0, do dfs, and maintain freq
  # all nodes will be visited just once
  n = colors.size
  graph = Array.new(n) {[]}
  i_deg = Array.new(n, 0)
  edges.each { |u,v| graph[u]<<v; i_deg[v]+=1 }
  queue = (0...n).select { |i| i_deg[i]==0 }
  max_color_value =  0
  node_processed_count = 0
  
  # max char count for each node as ending point in any path
  # multiple path will arrive at node, keep track of max for each char
  char_count = Array.new(n).map { [0]*26 }
  
  # kahns algorithm
  until queue.empty?
    node = queue.shift
    char_count[node][colors[node].ord - 'a'.ord]+=1
    node_processed_count+=1

    graph[node].each do |neighbor|
      # maintain max count for each char in neighbors
      (0...26).each {|i| char_count[neighbor][i] = [char_count[neighbor][i], char_count[node][i]].max  }
      i_deg[neighbor]-=1
      queue << neighbor if i_deg[neighbor]==0
    end
  end


  # cycles are not processed in kahns
  node_processed_count < n ? -1 : char_count.flatten.max 
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>