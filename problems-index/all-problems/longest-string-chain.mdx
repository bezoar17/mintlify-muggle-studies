---
title: "ðŸ§€ Longest String Chain"
description: '[leetcode link](https://leetcode.com/problems/longest-string-chain/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given an array of <code>words</code> where each word consists of lowercase English letters.</p>  <p><code>word<sub>A</sub></code> is a <strong>predecessor</strong> of <code>word<sub>B</sub></code> if and only if we can insert <strong>exactly one</strong> letter anywhere in <code>word<sub>A</sub></code> <strong>without changing the order of the other characters</strong> to make it equal to <code>word<sub>B</sub></code>.</p>  <ul>  <li>For example, <code>&quot;abc&quot;</code> is a <strong>predecessor</strong> of <code>&quot;ab<u>a</u>c&quot;</code>, while <code>&quot;cba&quot;</code> is not a <strong>predecessor</strong> of <code>&quot;bcad&quot;</code>.</li> </ul>  <p>A <strong>word chain</strong><em> </em>is a sequence of words <code>[word<sub>1</sub>, word<sub>2</sub>, ..., word<sub>k</sub>]</code> with <code>k &gt;= 1</code>, where <code>word<sub>1</sub></code> is a <strong>predecessor</strong> of <code>word<sub>2</sub></code>, <code>word<sub>2</sub></code> is a <strong>predecessor</strong> of <code>word<sub>3</sub></code>, and so on. A single word is trivially a <strong>word chain</strong> with <code>k == 1</code>.</p>  <p>Return <em>the <strong>length</strong> of the <strong>longest possible word chain</strong> with words chosen from the given list of </em><code>words</code>.</p>   <p><strong class="example">Example 1:</strong></p>   <strong>Input:</strong> words = [&quot;a&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bca&quot;,&quot;bda&quot;,&quot;bdca&quot;] <br/> <strong>Output:</strong> 4 <strong>Explanation</strong>: One of the longest word chains is [&quot;a&quot;,&quot;<u>b</u>a&quot;,&quot;b<u>d</u>a&quot;,&quot;bd<u>c</u>a&quot;].   <p><strong class="example">Example 2:</strong></p>   <strong>Input:</strong> words = [&quot;xbc&quot;,&quot;pcxbcf&quot;,&quot;xb&quot;,&quot;cxbc&quot;,&quot;pcxbc&quot;] <br/> <strong>Output:</strong> 5 <br/> <strong>Explanation:</strong> All the words can be put in a word chain [&quot;xb&quot;, &quot;xb<u>c</u>&quot;, &quot;<u>c</u>xbc&quot;, &quot;<u>p</u>cxbc&quot;, &quot;pcxbc<u>f</u>&quot;].   <p><strong class="example">Example 3:</strong></p>   <strong>Input:</strong> words = [&quot;abcd&quot;,&quot;dbqca&quot;] <br/> <strong>Output:</strong> 1 <br/> <strong>Explanation:</strong> The trivial word chain [&quot;abcd&quot;] is one of the longest word chains. [&quot;abcd&quot;,&quot;dbqca&quot;] is not a valid word chain because the ordering of the letters is changed.    <p><strong>Constraints:</strong></p>  <ul>  <li><code>1 &lt;= words.length &lt;= 1000</code></li>  <li><code>1 &lt;= words[i].length &lt;= 16</code></li>  <li><code>words[i]</code> only consists of lowercase English letters.</li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Group all words by word_len. Starting from the first len going to max len. Store what is the max chain at each step. If no word of len 2 exist, for all words of size 3, max_len is reset to 1. For each word_len, store hash of all words with their max_len. And for the next iteration with say word_len+1,  check all these words by deleting each char in them, and seeing if the resulting word exits in the previous lengths hash, if it does, for this word, we are extending the chain. At each step, store the max_chain_len value from the hash values as the answer.
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Longest String Chain" lines
# @param {String[]} words
# @return {Integer}
def longest_str_chain(words)
  grouped = words.group_by(&:size)
  chain_length_h = Hash.new(0)
  grouped.keys.sort.each do |word_len|
    # if predecessor is not present for this word length, max len is 1 for all these words.
    grouped[word_len].each { |word| chain_length_h[word] = 1 } and next unless grouped.key?(word_len - 1) 

    # for each word of this len, update max len of word chain, by checking all possible deletions,
    # as word len is at max 16, wont be a bad way to check by deleting all possible chars
    grouped[word_len].each do |word|
      chain_length_h[word] = 1 + word_len.times.map { |middle| chain_length_h["#{word[...middle]}#{word[middle + 1..]}"] }.max
    end
  end
  chain_length_h.values.max
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>