---
title: "ðŸ§€ Move Pieces to Obtain a String"
description: '[leetcode link](https://leetcode.com/problems/move-pieces-to-obtain-a-string/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given two strings <code>start</code> and <code>target</code>, both of length <code>n</code>. Each string consists <strong>only</strong> of the characters <code>&#39;L&#39;</code>, <code>&#39;R&#39;</code>, and <code>&#39;_&#39;</code> where:</p>  <ul>  <li>The characters <code>&#39;L&#39;</code> and <code>&#39;R&#39;</code> represent pieces, where a piece <code>&#39;L&#39;</code> can move to the <strong>left</strong> only if there is a <strong>blank</strong> space directly to its left, and a piece <code>&#39;R&#39;</code> can move to the <strong>right</strong> only if there is a <strong>blank</strong> space directly to its right.</li>  <li>The character <code>&#39;_&#39;</code> represents a blank space that can be occupied by <strong>any</strong> of the <code>&#39;L&#39;</code> or <code>&#39;R&#39;</code> pieces.</li> </ul>  <p>Return <code>true</code> <em>if it is possible to obtain the string</em> <code>target</code><em> by moving the pieces of the string </em><code>start</code><em> <strong>any</strong> number of times</em>. Otherwise, return <code>false</code>.</p>   <p><strong class="example">Example 1:</strong></p>   <strong>Input:</strong> start = &quot;_L__R__R_&quot;, target = &quot;L______RR&quot; <br/> <strong>Output:</strong> true <br/> <strong>Explanation:</strong> We can obtain the string target from start by doing the following moves: - Move the first piece one step to the left, start becomes equal to &quot;<strong>L</strong>___R__R_&quot;. - Move the last piece one step to the right, start becomes equal to &quot;L___R___<strong>R</strong>&quot;. - Move the second piece three steps to the right, start becomes equal to &quot;L______<strong>R</strong>R&quot;. Since it is possible to get the string target from start, we return true.   <p><strong class="example">Example 2:</strong></p>   <strong>Input:</strong> start = &quot;R_L_&quot;, target = &quot;__LR&quot; <br/> <strong>Output:</strong> false <br/> <strong>Explanation:</strong> The &#39;R&#39; piece in the string start can move one step to the right to obtain &quot;_<strong>R</strong>L_&quot;. After that, no pieces can move anymore, so it is impossible to obtain the string target from start.   <p><strong class="example">Example 3:</strong></p>   <strong>Input:</strong> start = &quot;_R&quot;, target = &quot;R_&quot; <br/> <strong>Output:</strong> false <br/> <strong>Explanation:</strong> The piece in the string start can move only to the right, so it is impossible to obtain the string target from start.   <p><strong>Constraints:</strong></p>  <ul>  <li><code>n == start.length == target.length</code></li>  <li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>  <li><code>start</code> and <code>target</code> consist of the characters <code>&#39;L&#39;</code>, <code>&#39;R&#39;</code>, and <code>&#39;_&#39;</code>.</li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      For all L, idx in start &gt;= idx in target. For r, all idx in start &lt;= target. And relative order of L R should not change.
I checked using simple sort method, can be done by queue/pointers etc.
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Move Pieces to Obtain a String" lines
# @param {String} start
# @param {String} target
# @return {Boolean}
def can_change(start, target)
  n = start.size
  # count and order of lr should remain same as target
  # for every L in target at idx, in start it should be >= idx,
  # same for R., start should be <=idx
  # target = __RL, start R__L
  # RRR_, R_RR
  start_l_idxs = start.chars.each_with_index.select {|x| x[0]=='L'};
  start_r_idxs = start.chars.each_with_index.select {|x| x[0]=="R"};

  target_l_idxs = target.chars.each_with_index.select {|x| x[0]=='L'};
  target_r_idxs = target.chars.each_with_index.select {|x| x[0]=="R"};

  return false if (start_l_idxs.size != target_l_idxs.size )|| (start_r_idxs.size != target_r_idxs.size)

  all_l_correct = start_l_idxs.zip(target_l_idxs).map{_1[1]-_2[1]}.all? {|x| x>=0}
  all_r_correct = start_r_idxs.zip(target_r_idxs).map{_1[1]-_2[1]}.all? {|x| x<=0}

  # relative order of l, r should be same
  order_same = (start_l_idxs + start_r_idxs).sort_by{_1[1]}.zip((target_l_idxs + target_r_idxs).sort_by{_1[1]}).all?{_1[0]==_2[0]}

  puts "#{all_l_correct} #{all_r_correct} #{order_same}"
  all_l_correct && all_r_correct && order_same
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>