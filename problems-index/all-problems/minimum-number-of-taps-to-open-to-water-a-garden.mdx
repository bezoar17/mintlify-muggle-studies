---
title: "❗️ Minimum Number of Taps to Open to Water a Garden"
description: '[leetcode link](https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>There is a one-dimensional garden on the x-axis. The garden starts at the point <code>0</code> and ends at the point <code>n</code>. (i.e., the&nbsp;length of the garden is <code>n</code>).</p>  <p>There are <code>n + 1</code> taps located at points <code>[0, 1, ..., n]</code> in the garden.</p>  <p>Given an integer <code>n</code> and an integer array <code>ranges</code> of length <code>n + 1</code> where <code>ranges[i]</code> (0-indexed) means the <code>i-th</code> tap can water the area <code>[i - ranges[i], i + ranges[i]]</code> if it was open.</p>  <p>Return <em>the minimum number of taps</em> that should be open to water the whole garden, If the garden cannot be watered return <strong>-1</strong>.</p>   <p><strong class="example">Example 1:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2020/01/16/1685_example_1.png" style="width: 525px; height: 255px;" />  <strong>Input:</strong> n = 5, ranges = [3,4,1,1,0,0] <br/> <strong>Output:</strong> 1 <br/> <strong>Explanation:</strong> The tap at point 0 can cover the interval [-3,3] The tap at point 1 can cover the interval [-3,5] The tap at point 2 can cover the interval [1,3] The tap at point 3 can cover the interval [2,4] The tap at point 4 can cover the interval [4,4] The tap at point 5 can cover the interval [5,5] Opening Only the second tap will water the whole garden [0,5]   <p><strong class="example">Example 2:</strong></p>   <strong>Input:</strong> n = 3, ranges = [0,0,0,0] <br/> <strong>Output:</strong> -1 <br/> <strong>Explanation:</strong> Even if you activate all the four taps you cannot water the whole garden.    <p><strong>Constraints:</strong></p>  <ul>  <li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>  <li><code>ranges.length == n + 1</code></li>  <li><code>0 &lt;= ranges[i] &lt;= 100</code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      The hint is the solution.

But to do that, theres a clever way, initialize taps needed to INF for all.

Update start to 0.

First range which affects this will be set to 1.
Suppose its [0,5]. Then dp[5] will have value 1. 

When n intervals comes which overlap with [0,5]. We set all their ends to 1+1. Hence max of these intervals will have value 2.

We keep processing intervals in such way, if dp[n] is not INF, it hold minimum taps.

Incase 1 is not set, all subsequent values will be INF only.
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Minimum Number of Taps to Open to Water a Garden" lines
# @param {Integer} n
# @param {Integer[]} ranges
# @return {Integer}
def min_taps(n, ranges)
  dp = Array.new(n+1, Float::INFINITY)
  dp[0] = 0

  (0..n).each do |i|
    tap_start = (i-ranges[i]).clamp(0,n)
    tap_end = (i + ranges[i]).clamp(0,n)

    (tap_start..tap_end).each do |j|
      dp[tap_end] = [dp[tap_end], dp[j] + 1].min 
    end
  end

  dp[n] == Float::INFINITY ? -1 : dp[n]
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>