---
title: 'ðŸ§€ Unique Paths'
description: '[leetcode link](https://leetcode.com/problems/unique-paths/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>There is a robot on an <code>m x n</code> grid. The robot is initially located at the <strong>top-left corner</strong> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p>  <p>Given the two integers <code>m</code> and <code>n</code>, return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p>  <p>The test cases are generated so that the answer will be less than or equal to <code>2 * 10<sup>9</sup></code>.</p>   <p><strong class="example">Example 1:</strong></p> <img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" style="width: 400px; height: 183px;" />  <strong>Input:</strong> m = 3, n = 7 <br/> <strong>Output:</strong> 28   <p><strong class="example">Example 2:</strong></p>   <strong>Input:</strong> m = 3, n = 2 <br/> <strong>Output:</strong> 3 <br/> <strong>Explanation:</strong> From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 1. Right -&gt; Down -&gt; Down 2. Down -&gt; Down -&gt; Right 3. Down -&gt; Right -&gt; Down    <p><strong>Constraints:</strong></p>  <ul>  <li><code>1 &lt;= m, n &lt;= 100</code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      There will be m-1 down values, and n-1 right values. Whatever order we can arrange them in is the answer, so (n-1+m-1)! / ( (m-1)! * (n-1)! ). Or, we just sum the top and left cells values, with base case being 1 for first row and column.
    </Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Unique Paths" lines
# @param {Integer} m
# @param {Integer} n
# @return {Integer}
def unique_paths(m, n)
  factorial=->(i) { i==0 ? 1 : (1..i).reduce(&:*) }
  factorial.call( m-1+n-1) / ( factorial.call(m-1) * factorial.call(n-1) )
end

```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>