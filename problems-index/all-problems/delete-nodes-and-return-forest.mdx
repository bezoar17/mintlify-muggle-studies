---
title: 'ðŸ§€ Delete Nodes And Return Forest'
description: '[leetcode link](https://leetcode.com/problems/delete-nodes-and-return-forest/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>Given the <code>root</code> of a binary tree, each node in the tree has a distinct value.</p>  <p>After deleting all nodes with a value in <code>to_delete</code>, we are left with a forest (a disjoint union of trees).</p>  <p>Return the roots of the trees in the remaining forest. You may return the result in any order.</p>   <p><strong class="example">Example 1:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2019/07/01/screen-shot-2019-07-01-at-53836-pm.png" style="width: 237px; height: 150px;" />  <strong>Input:</strong> root = [1,2,3,4,5,6,7], to_delete = [3,5] <br/> <strong>Output:</strong> [[1,2,null,4],[6],[7]]   <p><strong class="example">Example 2:</strong></p>   <strong>Input:</strong> root = [1,2,4,null,3], to_delete = [3] <br/> <strong>Output:</strong> [[1,2,4]]    <p><strong>Constraints:</strong></p>  <ul>  <li>The number of nodes in the given tree is at most <code>1000</code>.</li>  <li>Each node has a distinct value between <code>1</code> and <code>1000</code>.</li>  <li><code>to_delete.length &lt;= 1000</code></li>  <li><code>to_delete</code> contains distinct values between <code>1</code> and <code>1000</code>.</li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      BFS to process all nodes. Queue and then remove the connection. If node was deleted, then its children will be forests.

Roots check will be separate from this.
    </Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Delete Nodes And Return Forest" lines
# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @param {Integer[]} to_delete
# @return {TreeNode[]}
def del_nodes(root, to_delete)
  forests = []; to_delete_set = to_delete.to_set
  return [] if root.nil?
  forests << root unless to_delete_set.include?(root.val)

  queue = Queue.new
  queue << root

  until queue.empty?
    node = queue.pop
    unless node.left.nil?
      queue << node.left; node.left = nil if to_delete_set.include?(node.left.val)
    end
    unless node.right.nil?
      queue << node.right; node.right = nil if to_delete_set.include?(node.right.val)
    end

    if to_delete_set.include?(node.val) # when node is deleted, undeleted children are forest
      forests << node.left unless node.left.nil?
      forests << node.right unless node.right.nil?
    end
  end
  
  forests
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>