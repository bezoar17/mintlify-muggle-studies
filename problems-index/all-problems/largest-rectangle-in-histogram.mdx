---
title: '❗️ Largest Rectangle in Histogram'
description: '[leetcode link](https://leetcode.com/problems/largest-rectangle-in-histogram/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>Given an array of integers <code>heights</code> representing the histogram&#39;s bar height where the width of each bar is <code>1</code>, return <em>the area of the largest rectangle in the histogram</em>.</p>   <p><strong class="example">Example 1:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg" style="width: 522px; height: 242px;" />  <strong>Input:</strong> heights = [2,1,5,6,2,3] <br/> <strong>Output:</strong> 10 <br/> <strong>Explanation:</strong> The above is a histogram where width of each bar is 1. The largest rectangle is shown in the red area, which has an area = 10 units.   <p><strong class="example">Example 2:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg" style="width: 202px; height: 362px;" />  <strong>Input:</strong> heights = [2,4] <br/> <strong>Output:</strong> 4    <p><strong>Constraints:</strong></p>  <ul>  <li><code>1 &lt;= heights.length &lt;= 10<sup>5</sup></code></li>  <li><code>0 &lt;= heights[i] &lt;= 10<sup>4</sup></code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      No notes for this problem
    </Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Largest Rectangle in Histogram" lines
# @param {Integer[]} heights
# @return {Integer}
def largest_rectangle_area(heights)
  n = heights.size
  prev_smaller_idx = smaller_idx(heights, -1)
  next_smaller_idx = smaller_idx(heights, 1)

  (0...n).reduce(0) do |res, i|
    rect_length = next_smaller_idx[i]-prev_smaller_idx[i]-1
    area_at_i = heights[i] * rect_length
    [res, area_at_i].max
  end
end

def discard?(top,num) = top>=num;

def smaller_idx(nums, direction)
  n = nums.size
  calculate_previous = direction == -1;
  default, index_range = calculate_previous ? [-1, (0...n)] : [n, (n-1).downto(0)]

  result = Array.new(nums.size, default)
  stack = [] # stores only the index of element, not [element, idx]

  index_range.each do |idx|
    stack.pop while !stack.empty? && discard?(nums[stack.last], nums[idx])
    result[idx] = stack.last unless stack.empty?
    stack << idx
  end
  result
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>