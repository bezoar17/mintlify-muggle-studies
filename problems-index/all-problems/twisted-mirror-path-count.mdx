---
title: 'ðŸ§€ Twisted Mirror Path Count'
description: '[leetcode link](https://leetcode.com/problems/twisted-mirror-path-count/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>Given an <code>m x n</code> binary grid <code>grid</code> where:</p>  <ul>  <li><code>grid[i][j] == 0</code> represents an empty cell, and</li>  <li><code>grid[i][j] == 1</code> represents a mirror.</li> </ul>  <p>A robot starts at the top-left corner of the grid <code>(0, 0)</code> and wants to reach the bottom-right corner <code>(m - 1, n - 1)</code>. It can move only <strong>right</strong> or <strong>down</strong>. If the robot attempts to move into a mirror cell, it is <strong>reflected</strong> before entering that cell:</p>  <ul>  <li>If it tries to move <strong>right</strong> into a mirror, it is turned <strong>down</strong> and moved into the cell directly below the mirror.</li>  <li>If it tries to move <strong>down</strong> into a mirror, it is turned <strong>right</strong> and moved into the cell directly to the right of the mirror.</li> </ul>  <p>If this reflection would cause the robot to move outside the <code>grid</code> boundaries, the path is considered invalid and should not be counted.</p>  <p>Return the number of unique valid paths from <code>(0, 0)</code> to <code>(m - 1, n - 1)</code>.</p>  <p>Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>  <p><strong>Note</strong>: If a reflection moves the robot into a mirror cell, the robot is immediately reflected again based on the direction it used to enter that mirror: if it entered while moving right, it will be turned down; if it entered while moving down, it will be turned right. This process will continue until either the last cell is reached, the robot moves out of bounds or the robot moves to a non-mirror cell.</p>   <p><strong class="example">Example 1:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">grid = [[0,1,0],[0,0,1],[1,0,0]]</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">5</span></p>  <p><br/> <strong>Explanation:</strong></p>  <table style="border: 1px solid black;">  <thead>   <tr>    <th align="center" style="border: 1px solid black;">Number</th>    <th align="left" style="border: 1px solid black;">Full Path</th>   </tr>  </thead>  <tbody>   <tr>    <td align="center" style="border: 1px solid black;">1</td>    <td align="left" style="border: 1px solid black;">(0, 0) &rarr; (0, 1) [M] &rarr; (1, 1) &rarr; (1, 2) [M] &rarr; (2, 2)</td>   </tr>   <tr>    <td align="center" style="border: 1px solid black;">2</td>    <td align="left" style="border: 1px solid black;">(0, 0) &rarr; (0, 1) [M] &rarr; (1, 1) &rarr; (2, 1) &rarr; (2, 2)</td>   </tr>   <tr>    <td align="center" style="border: 1px solid black;">3</td>    <td align="left" style="border: 1px solid black;">(0, 0) &rarr; (1, 0) &rarr; (1, 1) &rarr; (1, 2) [M] &rarr; (2, 2)</td>   </tr>   <tr>    <td align="center" style="border: 1px solid black;">4</td>    <td align="left" style="border: 1px solid black;">(0, 0) &rarr; (1, 0) &rarr; (1, 1) &rarr; (2, 1) &rarr; (2, 2)</td>   </tr>   <tr>    <td align="center" style="border: 1px solid black;">5</td>    <td align="left" style="border: 1px solid black;">(0, 0) &rarr; (1, 0) &rarr; (2, 0) [M] &rarr; (2, 1) &rarr; (2, 2)</td>   </tr>  </tbody> </table>  <ul data-end="606" data-start="521">  <li data-end="606" data-start="521">  <p data-end="606" data-start="523"><code>[M]</code> indicates the robot attempted to enter a mirror cell and instead reflected.</p>  </li> </ul> </div>  <p><strong class="example">Example 2:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">grid = [[0,0],[0,0]]</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">2</span></p>  <p><br/> <strong>Explanation:</strong></p>  <table style="border: 1px solid black;">  <thead>   <tr>    <th align="center" style="border: 1px solid black;">Number</th>    <th align="left" style="border: 1px solid black;">Full Path</th>   </tr>  </thead>  <tbody>   <tr>    <td align="center" style="border: 1px solid black;">1</td>    <td align="left" style="border: 1px solid black;">(0, 0) &rarr; (0, 1) &rarr; (1, 1)</td>   </tr>   <tr>    <td align="center" style="border: 1px solid black;">2</td>    <td align="left" style="border: 1px solid black;">(0, 0) &rarr; (1, 0) &rarr; (1, 1)</td>   </tr>  </tbody> </table> </div>  <p><strong class="example">Example 3:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">grid = </span>[[0,1,1],[1,1,0]]</p>  <p><br/> <strong>Output:</strong> 1</p>  <p><br/> <strong>Explanation:</strong></p>  <table style="border: 1px solid black;">  <thead>   <tr>    <th align="center" style="border: 1px solid black;">Number</th>    <th align="left" style="border: 1px solid black;">Full Path</th>   </tr>  </thead>  <tbody>   <tr>    <td align="center" style="border: 1px solid black;">1</td>    <td align="left" style="border: 1px solid black;">(0, 0) &rarr; (0, 1) [M] &rarr; (1, 1) [M] &rarr; (1, 2)</td>   </tr>  </tbody> </table> <code>(0, 0) &rarr; (1, 0) [M] &rarr; (1, 1) [M] &rarr; (2, 1)</code> goes out of bounds, so it is invalid.</div>   <p><strong>Constraints:</strong></p>  <ul>  <li data-end="41" data-start="21"><code data-end="39" data-start="21">m == grid.length</code></li>  <li data-end="67" data-start="44"><code data-end="65" data-start="44">n == grid[i].length</code></li>  <li data-end="91" data-start="70"><code data-end="89" data-start="70">2 &lt;= m, n &lt;= 500</code></li>  <li data-end="129" data-start="94"><code data-end="106" data-start="94">grid[i][j]</code> is either <code data-end="120" data-is-only-node="" data-start="117">0</code> or <code data-end="127" data-start="124">1</code>.</li>  <li data-end="169" data-start="132"><code data-end="167" data-start="132">grid[0][0] == grid[m - 1][n - 1] == 0</code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Extension/Variation of a classic DP

https://leetcode.com/problems/twisted-mirror-path-count/solutions/7144114/simplest-code-tabular-bottom-up-approach-intuitive-explanation-ruby-100

If there were no mirrors, the way you calculate the result for each cell is adding ways of reaching from left and from top. This will remain same for cases where there is no mirror around. But for cases where there is a mirror, for example,
if there is a mirror to the left of a cell, ways to reach from left to this cell becomes 0, but ways to reach from top remains as is. Similarly, if theres a mirror on top of this cell, ways to reach from top becomes 0. So, we essentially have to track the ways to reach from left or top separately, and use them in the calculations. In simple cases, to get total, we just sum it up, but to handle mirrors, we need to know the counts of top and left of the other cells separately.




    </Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Twisted Mirror Path Count" lines
# @param {Integer[][]} grid
# @return {Integer}
def unique_paths(grid)
  m = grid.size; n = grid[0].size; big_mod = 1_000_000_000 + 7
  
  dp = Array.new(m) { Array.new(n) {Array.new(2, 0)} }
  left = 0; top=1 # for readability
  
  # 0th row and col, update left and top initializations
  (0...n).each {|j| dp[0][j][left]=1; break if grid[0][j]==1 }
  (0...m).each {|i| dp[i][0][top]=1; break if grid[i][0]==1 }

  (1...m).each do |i|
    (1...n).each do |j|
      # if left cell is mirror, only take its top; if top cell is mirror, only take its left, else take both ways
      dp[i][j][left] = grid[i][j-1] == 1 ? dp[i][j-1][top] : (dp[i][j-1][left] + dp[i][j-1][top]) if j > 0
      dp[i][j][top] = grid[i-1][j] == 1 ? dp[i-1][j][left] : (dp[i-1][j][left] +  dp[i-1][j][top]) if i > 0
    end
  end

  dp[m-1][n-1].sum % big_mod
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>