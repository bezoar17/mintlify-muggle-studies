---
title: "❗️ Last Day Where You Can Still Cross"
description: '[leetcode link](https://leetcode.com/problems/last-day-where-you-can-still-cross/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>There is a <strong>1-based</strong> binary matrix where <code>0</code> represents land and <code>1</code> represents water. You are given integers <code>row</code> and <code>col</code> representing the number of rows and columns in the matrix, respectively.</p>  <p>Initially on day <code>0</code>, the <strong>entire</strong> matrix is <strong>land</strong>. However, each day a new cell becomes flooded with <strong>water</strong>. You are given a <strong>1-based</strong> 2D array <code>cells</code>, where <code>cells[i] = [r<sub>i</sub>, c<sub>i</sub>]</code> represents that on the <code>i<sup>th</sup></code> day, the cell on the <code>r<sub>i</sub><sup>th</sup></code> row and <code>c<sub>i</sub><sup>th</sup></code> column (<strong>1-based</strong> coordinates) will be covered with <strong>water</strong> (i.e., changed to <code>1</code>).</p>  <p>You want to find the <strong>last</strong> day that it is possible to walk from the <strong>top</strong> to the <strong>bottom</strong> by only walking on land cells. You can start from <strong>any</strong> cell in the top row and end at <strong>any</strong> cell in the bottom row. You can only travel in the<strong> four</strong> cardinal directions (left, right, up, and down).</p>  <p>Return <em>the <strong>last</strong> day where it is possible to walk from the <strong>top</strong> to the <strong>bottom</strong> by only walking on land cells</em>.</p>   <p><strong class="example">Example 1:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2021/07/27/1.png" style="width: 624px; height: 162px;" />  <strong>Input:</strong> row = 2, col = 2, cells = [[1,1],[2,1],[1,2],[2,2]] <br/> <strong>Output:</strong> 2 <br/> <strong>Explanation:</strong> The above image depicts how the matrix changes each day starting from day 0. The last day where it is possible to cross from top to bottom is on day 2.   <p><strong class="example">Example 2:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2021/07/27/2.png" style="width: 504px; height: 178px;" />  <strong>Input:</strong> row = 2, col = 2, cells = [[1,1],[1,2],[2,1],[2,2]] <br/> <strong>Output:</strong> 1 <br/> <strong>Explanation:</strong> The above image depicts how the matrix changes each day starting from day 0. The last day where it is possible to cross from top to bottom is on day 1.   <p><strong class="example">Example 3:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2021/07/27/3.png" style="width: 666px; height: 167px;" />  <strong>Input:</strong> row = 3, col = 3, cells = [[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]] <br/> <strong>Output:</strong> 3 <br/> <strong>Explanation:</strong> The above image depicts how the matrix changes each day starting from day 0. The last day where it is possible to cross from top to bottom is on day 3.    <p><strong>Constraints:</strong></p>  <ul>  <li><code>2 &lt;= row, col &lt;= 2 * 10<sup>4</sup></code></li>  <li><code>4 &lt;= row * col &lt;= 2 * 10<sup>4</sup></code></li>  <li><code>cells.length == row * col</code></li>  <li><code>1 &lt;= r<sub>i</sub> &lt;= row</code></li>  <li><code>1 &lt;= c<sub>i</sub> &lt;= col</code></li>  <li>All the values of <code>cells</code> are <strong>unique</strong>.</li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      https://leetcode.com/problems/bricks-falling-when-hit/description/ Similar to this.

Go in reverse, simulating reversed time, and check the first day when the top and bottom gets connected. So, it can stay connected till that day -1, basically 0 index based idx. Since we have to find the last day, after that day, it is anyways unconnected, so we can start from all water cells, and for each cell from the R-&gt;L, convert it to land, and at some point top and bottom will get connected.

UnionFind - clever usage, in both ways, on land and on water cells.
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Last Day Where You Can Still Cross" lines
# @param {Integer} row
# @param {Integer} col
# @param {Integer[][]} cells
# @return {Integer}
class UnionFind
  attr_accessor :nodes, :sizes
  attr_reader :max_set_size

  def initialize(node_keys=[])
    @nodes = {}
    @sizes = {}
    @max_set_size = 0
    node_keys.each { |i| root(i) }
  end

  # this will create a node key if it doesnt exist
  def root(i)
    nodes[i] ||= i; sizes[i] ||= 1; # create node if it doesnt exist

    while nodes[i] != i
      nodes[i] = nodes[nodes[i]] # path compression
      i = nodes[i]
    end
    i
  end

  def size_for(i)
    sizes[root(i)]
  end

  def union(i, j)
    root_of_i = root(i)
    root_of_j = root(j)

    return false if root_of_i == root_of_j

    if sizes[root_of_j] > sizes[root_of_i]
      nodes[root_of_i] = root_of_j
      sizes[root_of_j] += sizes[root_of_i]
    else
      nodes[root_of_j] = root_of_i
      sizes[root_of_i] += sizes[root_of_j]
    end
    @max_set_size = [@max_set_size, sizes[root_of_i], sizes[root_of_j]].max
  end
end

def latest_day_to_cross(row, col, cells)
  live_grid = Array.new(row) { Array.new(col, 1) } # start with all water
  idx =->(i,j) { col*i + j } # compression of (i,j) to 1 num idx 
  
  top = -1; bottom = (row-1) * col # last idx beyond boundaries
  uf = UnionFind.new([top, bottom])

  (cells.size-1).downto(0).each do |d|
    i = cells[d][0]-1; j = cells[d][1]-1;
    live_grid[i][j] = 0 # this cell reversed to land

    # connect this brick with neighbor bricks
    [[1,0],[-1,0],[0,1],[0,-1]].each do |di, dj| 
      uf.union(idx[i,j], idx[i+di, j+dj]) if (i+di).between?(0,row-1) && (j+dj).between?(0,col-1) && live_grid[i+di][j+dj] == 0
    end

    # connect top and bottoms, and check if top and bottom are connected
    uf.union(idx[i,j], top) if i == 0
    uf.union(idx[i,j], bottom) if i == row-1

    return d if uf.root(top) == uf.root(bottom)
  end
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>