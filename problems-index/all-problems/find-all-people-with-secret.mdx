---
title: "❗️ Find All People With Secret"
description: '[leetcode link](https://leetcode.com/problems/find-all-people-with-secret/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given an integer <code>n</code> indicating there are <code>n</code> people numbered from <code>0</code> to <code>n - 1</code>. You are also given a <strong>0-indexed</strong> 2D integer array <code>meetings</code> where <code>meetings[i] = [x<sub>i</sub>, y<sub>i</sub>, time<sub>i</sub>]</code> indicates that person <code>x<sub>i</sub></code> and person <code>y<sub>i</sub></code> have a meeting at <code>time<sub>i</sub></code>. A person may attend <strong>multiple meetings</strong> at the same time. Finally, you are given an integer <code>firstPerson</code>.</p>  <p>Person <code>0</code> has a <strong>secret</strong> and initially shares the secret with a person <code>firstPerson</code> at time <code>0</code>. This secret is then shared every time a meeting takes place with a person that has the secret. More formally, for every meeting, if a person <code>x<sub>i</sub></code> has the secret at <code>time<sub>i</sub></code>, then they will share the secret with person <code>y<sub>i</sub></code>, and vice versa.</p>  <p>The secrets are shared <strong>instantaneously</strong>. That is, a person may receive the secret and share it with people in other meetings within the same time frame.</p>  <p>Return <em>a list of all the people that have the secret after all the meetings have taken place. </em>You may return the answer in <strong>any order</strong>.</p>   <p><strong class="example">Example 1:</strong></p>   <strong>Input:</strong> n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1 <br/> <strong>Output:</strong> [0,1,2,3,5] <strong>Explanation: </strong>At time 0, person 0 shares the secret with person 1. At time 5, person 1 shares the secret with person 2. At time 8, person 2 shares the secret with person 3. At time 10, person 1 shares the secret with person 5.​​​​ Thus, people 0, 1, 2, 3, and 5 know the secret after all the meetings.   <p><strong class="example">Example 2:</strong></p>   <strong>Input:</strong> n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3 <br/> <strong>Output:</strong> [0,1,3] <br/> <strong>Explanation:</strong> At time 0, person 0 shares the secret with person 3. At time 2, neither person 1 nor person 2 know the secret. At time 3, person 3 shares the secret with person 0 and person 1. Thus, people 0, 1, and 3 know the secret after all the meetings.   <p><strong class="example">Example 3:</strong></p>   <strong>Input:</strong> n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1 <br/> <strong>Output:</strong> [0,1,2,3,4] <br/> <strong>Explanation:</strong> At time 0, person 0 shares the secret with person 1. At time 1, person 1 shares the secret with person 2, and person 2 shares the secret with person 3. Note that person 2 can share the secret at the same time as receiving it. At time 2, person 3 shares the secret with person 4. Thus, people 0, 1, 2, 3, and 4 know the secret after all the meetings.    <p><strong>Constraints:</strong></p>  <ul>  <li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>  <li><code>1 &lt;= meetings.length &lt;= 10<sup>5</sup></code></li>  <li><code>meetings[i].length == 3</code></li>  <li><code>0 &lt;= x<sub>i</sub>, y<sub>i </sub>&lt;= n - 1</code></li>  <li><code>x<sub>i</sub> != y<sub>i</sub></code></li>  <li><code>1 &lt;= time<sub>i</sub> &lt;= 10<sup>5</sup></code></li>  <li><code>1 &lt;= firstPerson &lt;= n - 1</code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Firstly process all meetings in sorted order of time. Assuming there was only 1 meeting at a time, we can just connect 2 people who have a meeting, if anyone was connected to 0 when the meeting happened, both will receive the secret, else none will. 

Now, only thing remains if at once, there are multiple meetings, and person is part of multiple meetings, if he gets access to the secret in any one of the meetings, all people in all meetings this guy attended get the secret.

We can connect all people having a meeting at the same time, in pairs according to meetings data, if there was a meeting in which someone with secret was present, that guy and all other people in meetings with him will be connected to 0. So, we process all the meetings at this time once more, and check if there is a meeting where no-one is connected to the 0th person, say 2-3, the current component would be 2,3. At a later time, if 2 connects with 0, it is not necessary that 3 will be connected. So, we need to reset this connection, before processing meetings at further time. In a meeting, if none of the person is finally connected to 0(if 1 is connected, both are, its either both or none) after processing all meetings at this time t, we reset these persons to single node component before processing next set of meetings at later time.
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Find All People With Secret" lines
# @param {Integer} n
# @param {Integer[][]} meetings
# @param {Integer} first_person
# @return {Integer[]}
class UnionFind
  attr_accessor :nodes, :sizes
  attr_reader :max_set_size

  def initialize(node_keys=[])
    @nodes = {}
    @sizes = {}
    @max_set_size = 0
    node_keys.each { |i| root(i) }
  end

  # this will create a node key if it doesnt exist
  def root(i)
    nodes[i] ||= i; sizes[i] ||= 1; # create node if it doesnt exist

    while nodes[i] != i
      nodes[i] = nodes[nodes[i]] # path compression
      i = nodes[i]
    end
    i
  end

  def size_for(i)
    sizes[root(i)]
  end

  def union(i, j)
    root_of_i = root(i)
    root_of_j = root(j)

    return false if root_of_i == root_of_j

    if sizes[root_of_j] > sizes[root_of_i]
      nodes[root_of_i] = root_of_j
      sizes[root_of_j] += sizes[root_of_i]
    else
      nodes[root_of_j] = root_of_i
      sizes[root_of_i] += sizes[root_of_j]
    end
    @max_set_size = [@max_set_size, sizes[root_of_i], sizes[root_of_j]].max
  end

  def reset(i)
    nodes[i] = i; sizes[i] = 1;
  end
end

def find_all_people(n, meetings, first_person)
  uf = UnionFind.new((0...n).to_a); uf.union(0, first_person)
  sorted_meetings = meetings.group_by {|x| x[-1]}.to_a.map{|k,v| [k,v.map{|i| i.first(2)}]}.sort_by{_1[0]}

  sorted_meetings.each do |time, calls|
    calls.each {|p1,p2| uf.union(p1,p2) }
    calls.each {|p1, p2| (uf.reset(p1);uf.reset(p2)) if uf.root(p1)!=uf.root(0) }
  end
  
  (0...n).select {|i| uf.root(i) == uf.root(0) }
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>