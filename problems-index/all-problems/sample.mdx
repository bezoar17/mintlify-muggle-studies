---
title: 'ðŸ§€ Jump Game IX'
description: '[https://leetcode.com/problems/jump-game-ix/description/](https://leetcode.com/problems/jump-game-ix/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given an integer array <code>nums</code>.</p>  <p>From any index <code>i</code>, you can jump to another index <code>j</code> under the following rules:</p>  <ul>  <li>Jump to index <code>j</code> where <code>j &gt; i</code> is allowed only if <code>nums[j] &lt; nums[i]</code>.</li>  <li>Jump to index <code>j</code> where <code>j &lt; i</code> is allowed only if <code>nums[j] &gt; nums[i]</code>.</li> </ul>  <p>For each index <code>i</code>, find the <strong>maximum</strong> <strong>value</strong> in <code>nums</code> that can be reached by following <strong>any</strong> sequence of valid jumps starting at <code>i</code>.</p>  <p>Return an array <code>ans</code> where <code>ans[i]</code> is the <strong>maximum</strong> <strong>value</strong> reachable starting from index <code>i</code>.</p>  <p>&nbsp;</p> <p><strong class="example">Example 1:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">nums = [2,1,3]</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">[2,2,3]</span></p>  <p><br/> <strong>Explanation:</strong></p>  <ul>  <li>For <code>i = 0</code>: No jump increases the value.</li>  <li>For <code>i = 1</code>: Jump to <code>j = 0</code> as <code>nums[j] = 2</code> is greater than <code>nums[i]</code>.</li>  <li>For <code>i = 2</code>: Since <code>nums[2] = 3</code> is the maximum value in <code>nums</code>, no jump increases the value.</li> </ul>  <p>Thus, <code>ans = [2, 2, 3]</code>.</p>  <ul> </ul> </div>  <p><strong class="example">Example 2:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">nums = [2,3,1]</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">[3,3,3]</span></p>  <p><br/> <strong>Explanation:</strong></p>  <ul>  <li>For <code>i = 0</code>: Jump forward to <code>j = 2</code> as <code>nums[j] = 1</code> is less than <code>nums[i] = 2</code>, then from <code>i = 2</code> jump to <code>j = 1</code> as <code>nums[j] = 3</code> is greater than <code>nums[2]</code>.</li>  <li>For <code>i = 1</code>: Since <code>nums[1] = 3</code> is the maximum value in <code>nums</code>, no jump increases the value.</li>  <li>For <code>i = 2</code>: Jump to <code>j = 1</code> as <code>nums[j] = 3</code> is greater than <code>nums[2] = 1</code>.</li> </ul>  <p>Thus, <code>ans = [3, 3, 3]</code>.</p> </div>  <p>&nbsp;</p> <p><strong>Constraints:</strong></p>  <ul>  <li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>  <li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup>â€‹â€‹â€‹â€‹â€‹â€‹â€‹</code></li> </ul>
    </Card>
    {/* <p>You are given an integer array <code>nums</code>.</p>  <p>From any index <code>i</code>, you can jump to another index <code>j</code> under the following rules:</p>  <ul>  <li>Jump to index <code>j</code> where <code>j &gt; i</code> is allowed only if <code>nums[j] &lt; nums[i]</code>.</li>  <li>Jump to index <code>j</code> where <code>j &lt; i</code> is allowed only if <code>nums[j] &gt; nums[i]</code>.</li> </ul>  <p>For each index <code>i</code>, find the <strong>maximum</strong> <strong>value</strong> in <code>nums</code> that can be reached by following <strong>any</strong> sequence of valid jumps starting at <code>i</code>.</p>  <p>Return an array <code>ans</code> where <code>ans[i]</code> is the <strong>maximum</strong> <strong>value</strong> reachable starting from index <code>i</code>.</p>  <p>&nbsp;</p> <p><strong class="example">Example 1:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">nums = [2,1,3]</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">[2,2,3]</span></p>  <p><br/> <strong>Explanation:</strong></p>  <ul>  <li>For <code>i = 0</code>: No jump increases the value.</li>  <li>For <code>i = 1</code>: Jump to <code>j = 0</code> as <code>nums[j] = 2</code> is greater than <code>nums[i]</code>.</li>  <li>For <code>i = 2</code>: Since <code>nums[2] = 3</code> is the maximum value in <code>nums</code>, no jump increases the value.</li> </ul>  <p>Thus, <code>ans = [2, 2, 3]</code>.</p>  <ul> </ul> </div>  <p><strong class="example">Example 2:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">nums = [2,3,1]</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">[3,3,3]</span></p>  <p><br/> <strong>Explanation:</strong></p>  <ul>  <li>For <code>i = 0</code>: Jump forward to <code>j = 2</code> as <code>nums[j] = 1</code> is less than <code>nums[i] = 2</code>, then from <code>i = 2</code> jump to <code>j = 1</code> as <code>nums[j] = 3</code> is greater than <code>nums[2]</code>.</li>  <li>For <code>i = 1</code>: Since <code>nums[1] = 3</code> is the maximum value in <code>nums</code>, no jump increases the value.</li>  <li>For <code>i = 2</code>: Jump to <code>j = 1</code> as <code>nums[j] = 3</code> is greater than <code>nums[2] = 1</code>.</li> </ul>  <p>Thus, <code>ans = [3, 3, 3]</code>.</p> </div>  <p>&nbsp;</p> <p><strong>Constraints:</strong></p>  <ul>  <li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>  <li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup>â€‹â€‹â€‹â€‹â€‹â€‹â€‹</code></li> </ul> */}
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
    {/* <Icon icon="clipboard"/> */}
    For any element at index i, it has access to all greater values in [0..i], basically prefix max. If that was the only jump allowed,
    the answer would simply be prefix_max(i) for all i.

    The other jump allowed is to the right to a smaller value, jumping to that idx allows us to increase the range of finding the max values, or extending the range for max calculation.

    For cases where prefix_max(i) &lt;= suffix_min(i+1..), i.e, no value in left is greater than any in right, the second kind of jump to the right is nullified, i.e, ans for i can only be prefix_max(i).

    When prefix_max(i) &gt; suffix_min(i+1..), then suppose the suffix min value was at position y which is in [i+1,n-1].
    For any idx, in [0,i], we can jump to the prefix_max position, then jump to y, essentially increasing our window of max calculation from [0,i] to [0,y]. So, for all such i, we can increase the window of consideration, and answer for all indices would be same, i.e max in [0,y].

    Essentially, because calculation of answer for ith idx, can depend on larger range(0,y) of y idx, which is to the right, we should process the values from right to left. The prefix_max is calculated for all idxs, then while we calculate the suffix_min, going from right to left, we can update the answers for left-ward idxs, by carrying the result of prefix_max values from the right-ward idxs to the left, whenever we have  prefix_max(i) &gt; suffix_min(i+1..), and we have to consider a larger range.
  </Card>
  <Expandable title="code">
     <CodeGroup dropdown>
      ```ruby title="Jump Game IX" lines
      # @param {Integer[]} nums
      # @return {Integer[]}
      def max_value(nums)
        n = nums.size
        prefix_max = Array.new(n, -Float::INFINITY)
        prefix_max[0] = nums.first
        (1...n).each {|i| prefix_max[i] = [prefix_max[i-1], nums[i]].max }

        result = prefix_max # default answer with only left jumps

        # calculation of suffix-min and result going from R->L
        curr_min = nums.last
        (n-2).downto(0).each do |i| # for i, curr_min contains min in [i+1..
          # if any element in [0..i] can be used to jump to [i+1..], we carry the result of (i+1..), i.e of larger range
          result[i] = result[i+1] if prefix_max[i] > curr_min

          curr_min = nums[i] if nums[i] < curr_min # update the min value for next iteration
        end

        result
      end
      ```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>