---
title: "❗️ Minimum Window Substring"
description: '[leetcode link](https://leetcode.com/problems/minimum-window-substring/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>Given two strings <code>s</code> and <code>t</code> of lengths <code>m</code> and <code>n</code> respectively, return <em>the <strong>minimum window</strong></em> <span data-keyword="substring-nonempty"><strong><em>substring</em></strong></span><em> of </em><code>s</code><em> such that every character in </em><code>t</code><em> (<strong>including duplicates</strong>) is included in the window</em>. If there is no such substring, return <em>the empty string </em><code>&quot;&quot;</code>.</p>  <p>The testcases will be generated such that the answer is <strong>unique</strong>.</p>   <p><strong class="example">Example 1:</strong></p>   <strong>Input:</strong> s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot; <br/> <strong>Output:</strong> &quot;BANC&quot; <br/> <strong>Explanation:</strong> The minimum window substring &quot;BANC&quot; includes &#39;A&#39;, &#39;B&#39;, and &#39;C&#39; from string t.   <p><strong class="example">Example 2:</strong></p>   <strong>Input:</strong> s = &quot;a&quot;, t = &quot;a&quot; <br/> <strong>Output:</strong> &quot;a&quot; <br/> <strong>Explanation:</strong> The entire string s is the minimum window.   <p><strong class="example">Example 3:</strong></p>   <strong>Input:</strong> s = &quot;a&quot;, t = &quot;aa&quot; <br/> <strong>Output:</strong> &quot;&quot; <br/> <strong>Explanation:</strong> Both &#39;a&#39;s from t must be included in the window. Since the largest window of s only has one &#39;a&#39;, return empty string.    <p><strong>Constraints:</strong></p>  <ul>  <li><code>m == s.length</code></li>  <li><code>n == t.length</code></li>  <li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>  <li><code>s</code> and <code>t</code> consist of uppercase and lowercase English letters.</li> </ul>   <p><strong>Follow up:</strong> Could you find an algorithm that runs in <code>O(m + n)</code> time?</p> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      No notes for this problem
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Minimum Window Substring" lines
# @param {String} s
# @param {String} t
# @return {String}
def min_window(s, t)
  m = s.size; n = t.size
  lp=0; rp=n-1;
  min_len = m; min_lp = 0; flag = false
  h_t = t.chars.reduce(Hash.new(0)) {|h_,ch| h_[ch]-=1; h_} # initialize deficit of characters
  return "" if m < n

  current_negative_count = h_t.size
  (0..rp).to_a.each do |i| # use .to_a to ensure (0..0) also runs for 0
    if h_t.include?(s[i])
      h_t[s[i]]+=1
      current_negative_count-=1 if h_t[s[i]] == 0
    end
  end

  # when rp reaches end, lp can still be updated if current_negative_count==0
  while(rp < m-1 || current_negative_count == 0)
    if current_negative_count == 0
      len = rp-lp + 1; flag = true
      min_len, min_lp = len, lp if len < min_len
      # move lp after updating char count and current_negative_count
      if h_t.include?(s[lp])
        h_t[s[lp]]-=1; current_negative_count+=1 if h_t[s[lp]] == -1
      end
      lp+=1;
    else
      # move rp and then update new char count and current_negative_count
      rp+=1;
      if h_t.include?(s[rp])
        h_t[s[rp]]+=1; current_negative_count-=1 if h_t[s[rp]] == 0
      end
    end
  end
  
  return flag ? s[min_lp, min_len] : ""
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>