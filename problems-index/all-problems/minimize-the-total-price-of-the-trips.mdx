---
title: "❗️ Minimize the Total Price of the Trips"
description: '[leetcode link](https://leetcode.com/problems/minimize-the-total-price-of-the-trips/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>There exists an undirected and unrooted tree with <code>n</code> nodes indexed from <code>0</code> to <code>n - 1</code>. You are given the integer <code>n</code> and a 2D integer array <code>edges</code> of length <code>n - 1</code>, where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the tree.</p>  <p>Each node has an associated price. You are given an integer array <code>price</code>, where <code>price[i]</code> is the price of the <code>i<sup>th</sup></code> node.</p>  <p>The <strong>price sum</strong> of a given path is the sum of the prices of all nodes lying on that path.</p>  <p>Additionally, you are given a 2D integer array <code>trips</code>, where <code>trips[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> indicates that you start the <code>i<sup>th</sup></code> trip from the node <code>start<sub>i</sub></code> and travel to the node <code>end<sub>i</sub></code> by any path you like.</p>  <p>Before performing your first trip, you can choose some <strong>non-adjacent</strong> nodes and halve the prices.</p>  <p>Return <em>the minimum total price sum to perform all the given trips</em>.</p>   <p><strong class="example">Example 1:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2023/03/16/diagram2.png" style="width: 541px; height: 181px;" />  <strong>Input:</strong> n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]] <br/> <strong>Output:</strong> 23 <br/> <strong>Explanation:</strong> The diagram above denotes the tree after rooting it at node 2. The first part shows the initial tree and the second part shows the tree after choosing nodes 0, 2, and 3, and making their price half. For the 1<sup>st</sup> trip, we choose path [0,1,3]. The price sum of that path is 1 + 2 + 3 = 6. For the 2<sup>nd</sup> trip, we choose path [2,1]. The price sum of that path is 2 + 5 = 7. For the 3<sup>rd</sup> trip, we choose path [2,1,3]. The price sum of that path is 5 + 2 + 3 = 10. The total price sum of all trips is 6 + 7 + 10 = 23. It can be proven, that 23 is the minimum answer that we can achieve.   <p><strong class="example">Example 2:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2023/03/16/diagram3.png" style="width: 456px; height: 111px;" />  <strong>Input:</strong> n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]] <br/> <strong>Output:</strong> 1 <br/> <strong>Explanation:</strong> The diagram above denotes the tree after rooting it at node 0. The first part shows the initial tree and the second part shows the tree after choosing node 0, and making its price half. For the 1<sup>st</sup> trip, we choose path [0]. The price sum of that path is 1. The total price sum of all trips is 1. It can be proven, that 1 is the minimum answer that we can achieve.    <p><strong>Constraints:</strong></p>  <ul>  <li><code>1 &lt;= n &lt;= 50</code></li>  <li><code>edges.length == n - 1</code></li>  <li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>  <li><code>edges</code> represents a valid tree.</li>  <li><code>price.length == n</code></li>  <li><code>price[i]</code> is an even integer.</li>  <li><code>1 &lt;= price[i] &lt;= 1000</code></li>  <li><code>1 &lt;= trips.length &lt;= 100</code></li>  <li><code>0 &lt;= start<sub>i</sub>, end<sub>i</sub>&nbsp;&lt;= n - 1</code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      https://leetcode.com/problems/minimize-the-total-price-of-the-trips/solutions/6337245/ruby-100-fast-explained-by-bezoar17-1pe2

Since there is only 1 path from A-&gt;B, just store contribution of each node in the final trip cost. Then starting from any node as root. Consider this node to be halved or not halved, and calculate the contribution of next node acc. to this.This is similar to https://leetcode.com/problems/house-robber-iii/description/.

So, we can implement house-robber-iii for a tree, with all nodes having price as price * freq. And instead of robbing/skipping, we choose between whole/half. And for multiple child, not only 2.

Why bipartite approach does not work ?

For example a node P has 2 children A and B, A further has 1 child C. Let's say the optimal solution is to halve B and C. If you use bipartite approach here then the graph is divided into &lbrace;P,C&rbrace; and &lbrace;A,B&rbrace; so you're gonna halve either P&C or A&B which are not gonna be optimal.
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Minimize the Total Price of the Trips" lines
# @param {Integer} n
# @param {Integer[][]} edges
# @param {Integer[]} price
# @param {Integer[][]} trips
# @return {Integer}
def minimum_total_price(n, edges, price, trips)
  adj_h = Hash.new { |h,k| h[k] = Set.new }
  edges.each { |a,b|  adj_h[a]<<b; adj_h[b]<<a }
  total_price = Array.new(n,0)
  
  # dfs for the trip, and updates a node's total price contribution
  travel=->((node, finish), visited=Set.new) {
    return total_price[node]+=price[node] if node==finish
    visited.add(node)
    
    adj_h[node].each do |neighbor|
      next if visited.include?(neighbor)
      return total_price[node]+=price[node] if travel.call([neighbor, finish], visited)
    end
    false
  }
  
  trips.each(&travel)
  
  dp = Array.new(n)
  
  # simulate both choices, return [half, full] for each node, see house robber 3 for a simpler version
  simulate=->(node, parent) {
    children = adj_h[node].select{|x| x!=parent}
    return [total_price[node]/2, total_price[node]] if children.empty? # base case for leaf node
    
    dp[node] ||= [
      # half choice for current node, child value is only the full choice
      total_price[node]/2 + children.sum { |child| simulate.call(child, node)[1] },
      # full choice for current node, child value is min of both choices
      total_price[node] + children.sum { |child| simulate.call(child, node).min }
    ]
  }
  simulate.call(0, -1).min # best of half, full choices
end

```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>