---
title: "❗️ Paint House III"
description: '[leetcode link](https://leetcode.com/problems/paint-house-iii/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>There is a row of <code>m</code> houses in a small city, each house must be painted with one of the <code>n</code> colors (labeled from <code>1</code> to <code>n</code>), some houses that have been painted last summer should not be painted again.</p>  <p>A neighborhood is a maximal group of continuous houses that are painted with the same color.</p>  <ul>  <li>For example: <code>houses = [1,2,2,3,3,2,1,1]</code> contains <code>5</code> neighborhoods <code>[&lbrace;1&rbrace;, &lbrace;2,2&rbrace;, &lbrace;3,3&rbrace;, &lbrace;2&rbrace;, &lbrace;1,1&rbrace;]</code>.</li> </ul>  <p>Given an array <code>houses</code>, an <code>m x n</code> matrix <code>cost</code> and an integer <code>target</code> where:</p>  <ul>  <li><code>houses[i]</code>: is the color of the house <code>i</code>, and <code>0</code> if the house is not painted yet.</li>  <li><code>cost[i][j]</code>: is the cost of paint the house <code>i</code> with the color <code>j + 1</code>.</li> </ul>  <p>Return <em>the minimum cost of painting all the remaining houses in such a way that there are exactly</em> <code>target</code> <em>neighborhoods</em>. If it is not possible, return <code>-1</code>.</p>   <p><strong class="example">Example 1:</strong></p>   <strong>Input:</strong> houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3 <br/> <strong>Output:</strong> 9 <br/> <strong>Explanation:</strong> Paint houses of this way [1,2,2,1,1] This array contains target = 3 neighborhoods, [&lbrace;1&rbrace;, &lbrace;2,2&rbrace;, &lbrace;1,1&rbrace;]. Cost of paint all houses (1 + 1 + 1 + 1 + 5) = 9.   <p><strong class="example">Example 2:</strong></p>   <strong>Input:</strong> houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3 <br/> <strong>Output:</strong> 11 <br/> <strong>Explanation:</strong> Some houses are already painted, Paint the houses of this way [2,2,1,2,2] This array contains target = 3 neighborhoods, [&lbrace;2,2&rbrace;, &lbrace;1&rbrace;, &lbrace;2,2&rbrace;].  Cost of paint the first and last house (10 + 1) = 11.   <p><strong class="example">Example 3:</strong></p>   <strong>Input:</strong> houses = [3,1,2,3], cost = [[1,1,1],[1,1,1],[1,1,1],[1,1,1]], m = 4, n = 3, target = 3 <br/> <strong>Output:</strong> -1 <br/> <strong>Explanation:</strong> Houses are already painted with a total of 4 neighborhoods [&lbrace;3&rbrace;,&lbrace;1&rbrace;,&lbrace;2&rbrace;,&lbrace;3&rbrace;] different of target = 3.    <p><strong>Constraints:</strong></p>  <ul>  <li><code>m == houses.length == cost.length</code></li>  <li><code>n == cost[i].length</code></li>  <li><code>1 &lt;= m &lt;= 100</code></li>  <li><code>1 &lt;= n &lt;= 20</code></li>  <li><code>1 &lt;= target &lt;= m</code></li>  <li><code>0 &lt;= houses[i] &lt;= n</code></li>  <li><code>1 &lt;= cost[i][j] &lt;= 10<sup>4</sup></code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      3D DP, to paint ith house, with jth colour, for k neighborhood targets. 
and return answer if it is possible.

for every i, k, we will iterate over all colors and calculate values;
painting cost will be added to houses that were not painted. 

selection will be based on i-1, and color, and k or k-1 neighborhoods based on whether color remains same or not.


Read code, it has explanation

Have also implemented a top-down approach (which is technically going forward with calculating possible routes taken, while colouring ith with jth colour)
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Paint House III" lines
# @param {Integer[]} houses
# @param {Integer[][]} cost
# @param {Integer} m
# @param {Integer} n
# @param {Integer} target
# @return {Integer}
def min_cost(houses, cost, m, n, target)
  max_cost = Float::INFINITY
  cache = Array.new(m) { Array.new(target+1) { Array.new(n+1) } }
  
  recursive = ->(i, nbhd_count, last_color) do
    return max_cost if nbhd_count > target
    return nbhd_count == target ? 0 : max_cost if i == m    
    
    cache[i][nbhd_count][last_color] ||= 
      if houses[i] != 0
        recursive.call(i+1, nbhd_count + (houses[i] == last_color ? 0 : 1), houses[i])
      else
        (1..n).reduce(max_cost) do |result, chosen_color|
          [ result, cost[i][chosen_color-1] + recursive.call(i+1, nbhd_count + (chosen_color == last_color ? 0 : 1), chosen_color)].min
        end
      end
  end

  min_cost = recursive.call(0, 0, 0)
  min_cost == max_cost ? -1 : min_cost
end

```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>