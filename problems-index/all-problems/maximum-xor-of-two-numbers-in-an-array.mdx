---
title: "ðŸ§€ Maximum XOR of Two Numbers in an Array"
description: '[leetcode link](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>Given an integer array <code>nums</code>, return <em>the maximum result of </em><code>nums[i] XOR nums[j]</code>, where <code>0 &lt;= i &lt;= j &lt; n</code>.</p>   <p><strong class="example">Example 1:</strong></p>   <strong>Input:</strong> nums = [3,10,5,25,2,8] <br/> <strong>Output:</strong> 28 <br/> <strong>Explanation:</strong> The maximum result is 5 XOR 25 = 28.   <p><strong class="example">Example 2:</strong></p>   <strong>Input:</strong> nums = [14,70,53,83,49,91,36,80,92,51,66,70] <br/> <strong>Output:</strong> 127    <p><strong>Constraints:</strong></p>  <ul>  <li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>5</sup></code></li>  <li><code>0 &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Bit Trie, given an array of numbers and a val. Used to find max xor with any of numbers in arr. For the nums in arr, build a Trie of their bit representation (height of trie will be max_bit_length of nums and val). Now for each bit in val from L-&gt;R (MSB to LSB). We traverse the trie trying to get 1 for the resulting XOR. So if val has 0 in MSB, we see if BitTrie has 1 at level0(MSB), we consider this path. At a given node in bit trie, if one of its child is not present, the other will be present for sure. This is useful for traversing, once we are at a path, once we have chosen a bit at a level, any value formed from path of its subtree is better than its sibling subtree. This is due to the fact that 100 &gt; 011. So if we choose to have 1 at MSB in output XOR, even if all other right bit elements become 0, it will still be greater than if we hadnt chosen 1 for MSB. So, for gettting max xor value with val, we only have to traverse the bit-trie and see what is that number. 


Useful, when we need to do this multiple times, and arr is changing incrementally and val is different too for each query.

In this case, we can go from L-&gt;R, at each point arr is [0..i-1], and val is nums[i]. This way we can try out all possible pairs of (i,j) when we go from L-&gt;R, build the arr and use nums[i] as val.

Another problem, where arr changes and val changes.
https://leetcode.com/problems/maximum-genetic-difference-query/ 
https://www.youtube.com/watch?v=OqcUWxkd5Rs For in-depth explanation for this problem.
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```python3 title="Maximum XOR of Two Numbers in an Array" lines
from typing import List, Dict
from collections import defaultdict

class BitTrieNode:
    def __init__(self):
        self.children = [None, None]
        self.nums_with_this_bit = 0

class BitTrie:
    def __init__(self, max_bit_length=32):
        self.max_bit_length = max_bit_length
        self.root = BitTrieNode()
    
    def update_count(self, num: int, update: int) -> None:
        node = self.root
        
        for bit_pos in range(self.max_bit_length, -1, -1):
            bit = (num >> bit_pos) & 1
            if node.children[bit] is None:
                node.children[bit] = BitTrieNode()
            node = node.children[bit]
            node.nums_with_this_bit += update
    
    def add(self, num: int) -> None:
        self.update_count(num, 1)
    
    def remove(self, num: int) -> None:
        self.update_count(num, -1)
    
    def max_xor_result_for(self, value: int) -> int:
        max_xor_value = 0
        node = self.root
        
        for bit_pos in range(self.max_bit_length, -1, -1):
            value_bit = (value >> bit_pos) & 1
            required_bit = value_bit ^ 1
            
            if (node.children[required_bit] is not None and 
                node.children[required_bit].nums_with_this_bit > 0):
                max_xor_value += 2 ** bit_pos
                node = node.children[required_bit]
            else:
                node = node.children[value_bit]
                
        return max_xor_value

class Solution:
    def findMaximumXOR(self, nums: List[int]) -> int:
        max_bit_length = max(num.bit_length() for num in nums)
        bit_trie = BitTrie(max_bit_length)
        bit_trie.add(nums[0])
        if len(nums) == 1:
            return 0
        max_result = 0
        for num in nums[1:]:
            max_result = max(max_result, bit_trie.max_xor_result_for(num))
            bit_trie.add(num)
        return max_result
                
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>