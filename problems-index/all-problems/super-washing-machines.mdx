---
title: "❗️ Super Washing Machines"
description: '[leetcode link](https://leetcode.com/problems/super-washing-machines/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You have <code>n</code> super washing machines on a line. Initially, each washing machine has some dresses or is empty.</p>  <p>For each move, you could choose any <code>m</code> (<code>1 &lt;= m &lt;= n</code>) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines at the same time.</p>  <p>Given an integer array <code>machines</code> representing the number of dresses in each washing machine from left to right on the line, return <em>the minimum number of moves to make all the washing machines have the same number of dresses</em>. If it is not possible to do it, return <code>-1</code>.</p>   <p><strong class="example">Example 1:</strong></p>   <strong>Input:</strong> machines = [1,0,5] <br/> <strong>Output:</strong> 3 <br/> <strong>Explanation:</strong> 1st move:    1     0 &lt;-- 5    =&gt;    1     1     4 2nd move:    1 &lt;-- 1 &lt;-- 4    =&gt;    2     1     3 3rd move:    2     1 &lt;-- 3    =&gt;    2     2     2   <p><strong class="example">Example 2:</strong></p>   <strong>Input:</strong> machines = [0,3,0] <br/> <strong>Output:</strong> 2 <br/> <strong>Explanation:</strong> 1st move:    0 &lt;-- 3     0    =&gt;    1     2     0 2nd move:    1     2 --&gt; 0    =&gt;    1     1     1   <p><strong class="example">Example 3:</strong></p>   <strong>Input:</strong> machines = [0,2,0] <br/> <strong>Output:</strong> -1 <br/> <strong>Explanation:</strong> It&#39;s impossible to make all three washing machines have the same number of dresses.    <p><strong>Constraints:</strong></p>  <ul>  <li><code>n == machines.length</code></li>  <li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>  <li><code>0 &lt;= machines[i] &lt;= 10<sup>5</sup></code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Slightly similar to https://leetcode.com/problems/distribute-coins-in-binary-tree/description/.

In each move, some idxs participate in the transfer and move dresses. If we can find how many times each idx would require participation, the max of this is our answer, say it is M moves. For any other idx that needed to participate in x moves, it can do in the same M moves, since all x &lt;=M, all idxs have covered their obligation of participation.

Now, after all moves, each idx would have target = machines.sum/n dresses. Imagine, a idx having target+x dresses. It definitely needs x moves, to discard all these dresses. So, our lower limit is max of excess dresses at any idx. If there is a deficit at an idx, say target-y. It does not necessarily need y moves, as it can receive 2 dresses from adjacent idxs in the same turn. Also, for an excess idx, having target+x dresses, it might participate in more than x moves, that happens when it acts as a dress passer, passing the dress from left half to right or vice versa.

If, we focus on each idx, checking in how many transfers it will be involved in. That is moves required for that idx. 

For a single machine, necessary operations is to transfer dresses from one side to another until sum of both sides and itself reaches the average number. We can calculate (required dresses) - (contained dresses) of each side as L and R:
L &gt; 0 && R &gt; 0: both sides **lacks dresses**, and we can only export **one** dress from current machines at a time, so result is abs(L) + abs(R)
L &lt; 0 && R &lt; 0: both sides contains **too many dresses**, and we can import dresses from both sides at the **same time**, so result is max(abs(L), abs(R))
L &lt; 0 && R &gt; 0 or L &gt;0 && R &lt; 0: the side with a **larger absolute value will import/export its extra dresses** from/to current machine or other side, so result is max(abs(L), abs(R))

For example, [1, 0, 5], average is 2
for 1, L = 0 * 2 - 0 = 0, R = 2 * 2 - 5= -1, result = 1
for 0, L = 1 * 2 - 1= 1, R = 1 * 2 - 5 = -3, result = 3
for 5, L = 2 * 2 - 1= 3, R = 0 * 2 - 0= 0, result = 3
so minium moves is 3
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Super Washing Machines" lines
# @param {Integer[]} machines
# @return {Integer}
def find_min_moves(machines)
  n = machines.size
  total_dress_count = machines.sum
  avg, rem = total_dress_count.divmod(n)
  return -1 if rem!=0
  # for an i, check left(0..i-1) and right(i+1..n) counts, and calculate moves req for i
  prefix = [0] # for i, prefix current dress sum till i-1
  machines.each { |x| prefix << x+prefix[-1] }

  moves_req = 0
  machines.each_with_index do |dress_count_i, i|
    l_deficit = i*avg - prefix[i] # expected - current dress count
    suffix_i = total_dress_count - (prefix[i] + dress_count_i)
    r_deficit = (n-1-i)*avg - suffix_i

    moves_i = if l_deficit > 0 && r_deficit > 0
                l_deficit.abs + r_deficit.abs # dresses flow from i, one at a time
              else
                [l_deficit.abs, r_deficit.abs].max # dresses flow into i, or go through i
              end

    moves_req = [moves_req, moves_i].max
  end

  moves_req
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>