---
title: 'ðŸ§€ Maximize the Number of Target Nodes After Connecting Trees I'
description: '[leetcode link](https://leetcode.com/problems/maximize-the-number-of-target-nodes-after-connecting-trees-i/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>There exist two <strong>undirected </strong>trees with <code>n</code> and <code>m</code> nodes, with <strong>distinct</strong> labels in ranges <code>[0, n - 1]</code> and <code>[0, m - 1]</code>, respectively.</p>  <p>You are given two 2D integer arrays <code>edges1</code> and <code>edges2</code> of lengths <code>n - 1</code> and <code>m - 1</code>, respectively, where <code>edges1[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the first tree and <code>edges2[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> indicates that there is an edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> in the second tree. You are also given an integer <code>k</code>.</p>  <p>Node <code>u</code> is <strong>target</strong> to node <code>v</code> if the number of edges on the path from <code>u</code> to <code>v</code> is less than or equal to <code>k</code>. <strong>Note</strong> that a node is <em>always</em> <strong>target</strong> to itself.</p>  <p>Return an array of <code>n</code> integers <code>answer</code>, where <code>answer[i]</code> is the <strong>maximum</strong> possible number of nodes <strong>target</strong> to node <code>i</code> of the first tree if you have to connect one node from the first tree to another node in the second tree.</p>  <p><strong>Note</strong> that queries are independent from each other. That is, for every query you will remove the added edge before proceeding to the next query.</p>   <p><strong class="example">Example 1:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">edges1 = [[0,1],[0,2],[2,3],[2,4]], edges2 = [[0,1],[0,2],[0,3],[2,7],[1,4],[4,5],[4,6]], k = 2</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">[9,7,9,8,8]</span></p>  <p><br/> <strong>Explanation:</strong></p>  <ul>  <li>For <code>i = 0</code>, connect node 0 from the first tree to node 0 from the second tree.</li>  <li>For <code>i = 1</code>, connect node 1 from the first tree to node 0 from the second tree.</li>  <li>For <code>i = 2</code>, connect node 2 from the first tree to node 4 from the second tree.</li>  <li>For <code>i = 3</code>, connect node 3 from the first tree to node 4 from the second tree.</li>  <li>For <code>i = 4</code>, connect node 4 from the first tree to node 4 from the second tree.</li> </ul> <img alt="" src="https://assets.leetcode.com/uploads/2024/09/24/3982-1.png" style="width: 600px; height: 169px;" /></div>  <p><strong class="example">Example 2:</strong></p>  <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">edges1 = [[0,1],[0,2],[0,3],[0,4]], edges2 = [[0,1],[1,2],[2,3]], k = 1</span></p>  <p><br/> <strong>Output:</strong> <span class="example-io">[6,3,3,3,3]</span></p>  <p><br/> <strong>Explanation:</strong></p>  <p>For every <code>i</code>, connect node <code>i</code> of the first tree with any node of the second tree.</p> <img alt="" src="https://assets.leetcode.com/uploads/2024/09/24/3928-2.png" style="height: 281px; width: 500px;" /></div>   <p><strong>Constraints:</strong></p>  <ul>  <li><code>2 &lt;= n, m &lt;= 1000</code></li>  <li><code>edges1.length == n - 1</code></li>  <li><code>edges2.length == m - 1</code></li>  <li><code>edges1[i].length == edges2[i].length == 2</code></li>  <li><code>edges1[i] = [a<sub>i</sub>, b<sub>i</sub>]</code></li>  <li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>  <li><code>edges2[i] = [u<sub>i</sub>, v<sub>i</sub>]</code></li>  <li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; m</code></li>  <li>The input is generated such that <code>edges1</code> and <code>edges2</code> represent valid trees.</li>  <li><code>0 &lt;= k &lt;= 1000</code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Let trees be T1 and T2. Suppose nodes with k distance are denoted by k_node_count. k_node_count value for T1 will remain as is after the join, but nodes from T2 will be added. Dist of nodes in T2 becomes k-1. So we choose the T2 node which has max k_node_count for k-1.

Task is to calculate k_node_count, and take max in T2 for k-1, then for each node in T1 ans is k_node_count_T1 + max_k-1_in_T2
    </Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```python3 title="Maximize the Number of Target Nodes After Connecting Trees I" lines
class Solution:
    def maxTargetNodes(self, edges1: List[List[int]], edges2: List[List[int]], k: int) -> List[int]:
        def k_node_count(edges, k):
          n = len(edges) + 1
          adj_dict = {}
          for u, v in edges:
              if u not in adj_dict:
                  adj_dict[u] = []
              if v not in adj_dict:
                  adj_dict[v] = []
              adj_dict[u].append(v)
              adj_dict[v].append(u)
          
          if k == 0:
              return [1] * n
          
          def dfs(node, dist, parent):
              if node is None or dist > k:
                  return 0
              
              children = [x for x in adj_dict.get(node, []) if x != parent]
              return 1 + sum(dfs(child, dist + 1, node) for child in children)
          
          return [dfs(i, 0, None) for i in range(n)]
      
        # Get node counts for edges2 with k-1 distance
        t2_node_counts = k_node_count(edges2, k-1)
        t2_max = max(t2_node_counts)
        
        # Add maximum count from edges2 to node counts from edges1
        return [x + t2_max for x in k_node_count(edges1, k)]
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>