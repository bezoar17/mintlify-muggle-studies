---
title: 'ðŸ§€ Most Stones Removed with Same Row or Column'
description: '[leetcode link](https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>On a 2D plane, we place <code>n</code> stones at some integer coordinate points. Each coordinate point may have at most one stone.</p>  <p>A stone can be removed if it shares either <strong>the same row or the same column</strong> as another stone that has not been removed.</p>  <p>Given an array <code>stones</code> of length <code>n</code> where <code>stones[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> represents the location of the <code>i<sup>th</sup></code> stone, return <em>the largest possible number of stones that can be removed</em>.</p>   <p><strong class="example">Example 1:</strong></p>   <strong>Input:</strong> stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]] <br/> <strong>Output:</strong> 5 <br/> <strong>Explanation:</strong> One way to remove 5 stones is as follows: 1. Remove stone [2,2] because it shares the same row as [2,1]. 2. Remove stone [2,1] because it shares the same column as [0,1]. 3. Remove stone [1,2] because it shares the same row as [1,0]. 4. Remove stone [1,0] because it shares the same column as [0,0]. 5. Remove stone [0,1] because it shares the same row as [0,0]. Stone [0,0] cannot be removed since it does not share a row/column with another stone still on the plane.   <p><strong class="example">Example 2:</strong></p>   <strong>Input:</strong> stones = [[0,0],[0,2],[1,1],[2,0],[2,2]] <br/> <strong>Output:</strong> 3 <br/> <strong>Explanation:</strong> One way to make 3 moves is as follows: 1. Remove stone [2,2] because it shares the same row as [2,0]. 2. Remove stone [2,0] because it shares the same column as [0,0]. 3. Remove stone [0,2] because it shares the same row as [0,0]. Stones [0,0] and [1,1] cannot be removed since they do not share a row/column with another stone still on the plane.   <p><strong class="example">Example 3:</strong></p>   <strong>Input:</strong> stones = [[0,0]] <br/> <strong>Output:</strong> 0 <br/> <strong>Explanation:</strong> [0,0] is the only stone on the plane, so you cannot remove it.    <p><strong>Constraints:</strong></p>  <ul>  <li><code>1 &lt;= stones.length &lt;= 1000</code></li>  <li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>4</sup></code></li>  <li>No two stones are at the same coordinate point.</li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      From each connected component, we can remove all but 1 stone. Max removal stone count is stones.size - no. of component. Connected component is all nodes which share either a row or col with each other. Use y values which dont overlap with x values, combine each x,y and then see how many components are left
    </Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Most Stones Removed with Same Row or Column" lines
# @param {Integer[][]} stones
# @return {Integer}
class UnionFind
  attr_accessor :nodes, :sizes
  attr_reader :max_set_size

  def initialize(node_keys=[])
    @nodes = {}
    @sizes = Hash.new(1)
    @max_set_size = 0
    node_keys.each { |i| root(i) }
  end

  # this will create a node key if it doesnt exist
  def root(i)
    nodes[i] ||= i; sizes[i] ||= 1; # create node if it doesnt exist

    while nodes[i] != i
      nodes[i] = nodes[nodes[i]] # path compression
      i = nodes[i]
    end
    i
  end

  def size_for(i)
    sizes[root(i)]
  end

  def union(i, j)
    root_of_i = root(i)
    root_of_j = root(j)

    return false if root_of_i == root_of_j

    if sizes[root_of_j] > sizes[root_of_i]
      nodes[root_of_i] = root_of_j
      sizes[root_of_j] += sizes[root_of_i]
    else
      nodes[root_of_j] = root_of_i
      sizes[root_of_i] += sizes[root_of_j]
    end
    @max_set_size = [@max_set_size, sizes[root_of_i], sizes[root_of_j]].max
  end
end

def remove_stones(stones)
  uf = UnionFind.new
  stones.each { |u,v| uf.union(u, v+1_000_1) }
  components = uf.nodes.count { |node,root| node==root }
  stones.size - components
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>