---
title: '❗️ Word Ladder'
description: '[leetcode link](https://leetcode.com/problems/word-ladder/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>A <strong>transformation sequence</strong> from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -&gt; s<sub>1</sub> -&gt; s<sub>2</sub> -&gt; ... -&gt; s<sub>k</sub></code> such that:</p>  <ul>  <li>Every adjacent pair of words differs by a single letter.</li>  <li>Every <code>s<sub>i</sub></code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li>  <li><code>s<sub>k</sub> == endWord</code></li> </ul>  <p>Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return <em>the <strong>number of words</strong> in the <strong>shortest transformation sequence</strong> from</em> <code>beginWord</code> <em>to</em> <code>endWord</code><em>, or </em><code>0</code><em> if no such sequence exists.</em></p>   <p><strong class="example">Example 1:</strong></p>   <strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;] <br/> <strong>Output:</strong> 5 <br/> <strong>Explanation:</strong> One shortest transformation sequence is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; cog&quot;, which is 5 words long.   <p><strong class="example">Example 2:</strong></p>   <strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;] <br/> <strong>Output:</strong> 0 <br/> <strong>Explanation:</strong> The endWord &quot;cog&quot; is not in wordList, therefore there is no valid transformation sequence.    <p><strong>Constraints:</strong></p>  <ul>  <li><code>1 &lt;= beginWord.length &lt;= 10</code></li>  <li><code>endWord.length == beginWord.length</code></li>  <li><code>1 &lt;= wordList.length &lt;= 5000</code></li>  <li><code>wordList[i].length == beginWord.length</code></li>  <li><code>beginWord</code>, <code>endWord</code>, and <code>wordList[i]</code> consist of lowercase English letters.</li>  <li><code>beginWord != endWord</code></li>  <li>All the words in <code>wordList</code> are <strong>unique</strong>.</li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Get shortest distance from begin to end using bfs. 
To get neighbors, generate and check if they are in given wordList.


Remove begin_word from initial set, to avoid a cycle, begin to next and then back to begin. 
    </Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Word Ladder" lines
# @param {String} begin_word
# @param {String} end_word
# @param {String[]} word_list
# @return {Integer}
def ladder_length(begin_word, end_word, word_list)
  word_set = Set.new(word_list)
  return 0 unless word_set.include?(end_word)
  word_set.delete(begin_word)
  
  # now do a simple bfs starting from begin_node, word_set will act as visited set too
  queue = [begin_word]
  distance = 0

  while !queue.empty?
    level = queue.size
    distance += 1

    level.times do
      node = queue.shift

      return distance if end_word == node

      one_change_away(node).select {|x|  word_set.include?(x) }.each do |x|
        word_set.delete(x)
        queue << x
      end
    end
  end

  0
end

def one_change_away(word)
  alpha = ("a".."z").to_a
  chars = word.split("")
  results = []
  
  for i in 0 ... chars.length do
    temp = chars[i]
    
    alpha.each do |letter|
      chars[i] = letter
      results.push(chars.join)
    end
    
    chars[i] = temp
  end
  
  results
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>