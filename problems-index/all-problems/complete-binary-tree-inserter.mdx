---
title: "ðŸ§€ Complete Binary Tree Inserter"
description: '[leetcode link](https://leetcode.com/problems/complete-binary-tree-inserter/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>A <strong>complete binary tree</strong> is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.</p>  <p>Design an algorithm to insert a new node to a complete binary tree keeping it complete after the insertion.</p>  <p>Implement the <code>CBTInserter</code> class:</p>  <ul>  <li><code>CBTInserter(TreeNode root)</code> Initializes the data structure with the <code>root</code> of the complete binary tree.</li>  <li><code>int insert(int v)</code> Inserts a <code>TreeNode</code> into the tree with value <code>Node.val == val</code> so that the tree remains complete, and returns the value of the parent of the inserted <code>TreeNode</code>.</li>  <li><code>TreeNode get_root()</code> Returns the root node of the tree.</li> </ul>   <p><strong class="example">Example 1:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2021/08/03/lc-treeinsert.jpg" style="width: 500px; height: 143px;" />  <strong>Input</strong> [&quot;CBTInserter&quot;, &quot;insert&quot;, &quot;insert&quot;, &quot;get_root&quot;] [[[1, 2]], [3], [4], []] <strong>Output</strong> [null, 1, 2, [1, 2, 3, 4]]  <strong>Explanation</strong> CBTInserter cBTInserter = new CBTInserter([1, 2]); cBTInserter.insert(3);  // return 1 cBTInserter.insert(4);  // return 2 cBTInserter.get_root(); // return [1, 2, 3, 4]    <p><strong>Constraints:</strong></p>  <ul>  <li>The number of nodes in the tree will be in the range <code>[1, 1000]</code>.</li>  <li><code>0 &lt;= Node.val &lt;= 5000</code></li>  <li><code>root</code> is a complete binary tree.</li>  <li><code>0 &lt;= val &lt;= 5000</code></li>  <li>At most <code>10<sup>4</sup></code> calls will be made to <code>insert</code> and <code>get_root</code>.</li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      No notes for this problem
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Complete Binary Tree Inserter" lines
# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val)
#         @val = val
#         @left, @right = nil, nil
#     end
# end

class CBTInserter

=begin
    :type root: TreeNode
=end
    def initialize(root)
        @root = root
        # maintain a simple bfs level-order queue but only comprising of
        # elements which have 0 or 1 children. if node has 2 children, dequeue from start
        @queue = build_queue(root)
    end

=begin
    :type v: Integer
    :rtype: Integer
=end
    def insert(v)
      node = TreeNode.new(v)
      @queue << node    
      parent_node = @queue[0]
      
      if parent_node.left.nil?
        parent_node.left = node
      else
        parent_node.right = node
        @queue.shift # parent now has 2 elements, so is removed from queue
      end
      
      return parent_node.val
    end
  
    def build_queue(root)
      init_queue = [root]; index = 0;

      while index<init_queue.size
        current_node = init_queue[index]
        init_queue += [current_node.left, current_node.right].compact
        index+=1
      end
      init_queue.select { |node|  node.left.nil? || node.right.nil? }
    end

=begin
    :rtype: TreeNode
=end
    def get_root()
        @root
    end
end

# Your CBTInserter object will be instantiated and called as such:
# obj = CBTInserter.new(root)
# param_1 = obj.insert(v)
# param_2 = obj.get_root()
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>