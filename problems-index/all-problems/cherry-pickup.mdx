---
title: '❗️ Cherry Pickup'
description: '[leetcode link](https://leetcode.com/problems/cherry-pickup/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given an <code>n x n</code> <code>grid</code> representing a field of cherries, each cell is one of three possible integers.</p>  <ul>  <li><code>0</code> means the cell is empty, so you can pass through,</li>  <li><code>1</code> means the cell contains a cherry that you can pick up and pass through, or</li>  <li><code>-1</code> means the cell contains a thorn that blocks your way.</li> </ul>  <p>Return <em>the maximum number of cherries you can collect by following the rules below</em>:</p>  <ul>  <li>Starting at the position <code>(0, 0)</code> and reaching <code>(n - 1, n - 1)</code> by moving right or down through valid path cells (cells with value <code>0</code> or <code>1</code>).</li>  <li>After reaching <code>(n - 1, n - 1)</code>, returning to <code>(0, 0)</code> by moving left or up through valid path cells.</li>  <li>When passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell <code>0</code>.</li>  <li>If there is no valid path between <code>(0, 0)</code> and <code>(n - 1, n - 1)</code>, then no cherries can be collected.</li> </ul>   <p><strong class="example">Example 1:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2020/12/14/grid.jpg" style="width: 242px; height: 242px;" />  <strong>Input:</strong> grid = [[0,1,-1],[1,0,-1],[1,1,1]] <br/> <strong>Output:</strong> 5 <br/> <strong>Explanation:</strong> The player started at (0, 0) and went down, down, right right to reach (2, 2). 4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]]. Then, the player went left, up, up, left to return home, picking up one more cherry. The total number of cherries picked up is 5, and this is the maximum possible.   <p><strong class="example">Example 2:</strong></p>   <strong>Input:</strong> grid = [[1,1,-1],[1,-1,1],[-1,1,1]] <br/> <strong>Output:</strong> 0    <p><strong>Constraints:</strong></p>  <ul>  <li><code>n == grid.length</code></li>  <li><code>n == grid[i].length</code></li>  <li><code>1 &lt;= n &lt;= 50</code></li>  <li><code>grid[i][j]</code> is <code>-1</code>, <code>0</code>, or <code>1</code>.</li>  <li><code>grid[0][0] != -1</code></li>  <li><code>grid[n - 1][n - 1] != -1</code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      Main thing to realise is 2 trips cant be considered in isolation, have to be considered in unison, state is state of both trips position.
We cant calculate trip1 and trip2 separately, or one by one, because if trip1 is maximized in isolation, it might leave out cherries like a split bowling position where 2nd person cant pick all remaining cherries, but if they trip1 were to take less than max and leave the grid in a state that trip2 can collect all remaining. Basically, 2 sub-optimal trips might have greater sum than either of the trip maximizing itself first, and then the other goes. To calculate together max, we need to process trip state simulaneously. 

1 such case is , if first takes 9(max in isolation), 2nd cant take both. 
11100
00101
10100
00100
00111

A backtracking solution which tracks all paths is possible but will mostly time out.

But if we look at it a different way, for trip2 from bottom to top, if we just reverse the path, then question becomes, how can we maximize 2 people T1 and T2 walking from top to bottom at once, not in isolation, with max cherries.

For any path with t steps, r+c=t. For 2 people taking t steps, r1+c1 = r2+c2 = t. Given this, to maintain state after 3 steps, we dont need all 4 values, as r2 can be calculated using r1,c1,c2. This is representation of state for 2 person trip, which give N^3 solution. Only thing to take care of is if both are at same cell after t steps, we dont double count the cherry.
    </Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Cherry Pickup" lines
# @param {Integer[][]} grid
# @return {Integer}
def cherry_pickup(grid)
  n = grid.size
  dp = Array.new(n) { Array.new(n) { Array.new(n) }}

  # track 2 positions of 2 simulatneous trips, 1 step at a time
  # because for t steps, r+c=t for both trips, we need only 3 values to keep track of 2 positions after t steps
  recursive =->(r1, c1, c2){
    r2 = r1 + c1 - c2
    
    return -Float::INFINITY if [r1,r2,c1,c2].include?(n) || grid[r1][c1]==-1 || grid[r2][c2]==-1
    return grid[r1][c1] if r1==n-1 && c1==n-1
    return dp[r1][c1][c2] unless dp[r1][c1][c2].nil?

    # ans = grid[r1][c1] + ((r1==r2 && c1==c2) ? 0 : grid[r2][c2])
    # for same cell condition, because of equation, we can only check c1, c2, then r1r2 will also be equal
    ans = grid[r1][c1] + (c1==c2 ? 0 : grid[r2][c2])
    ans += [
      recursive.call(r1, c1+1, c2+1), # 1 moves right, 2 moves right
      recursive.call(r1, c1+1, c2), # 1 moves right, 2 moves down
      recursive.call(r1+1, c1, c2), # 1 moves down, 2 moves down
      recursive.call(r1+1, c1, c2+1), # 1 moves down, 2 moves right
    ].max

    dp[r1][c1][c2] = ans
  }

  [recursive.call(0,0,0), 0].max
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>