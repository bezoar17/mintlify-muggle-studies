---
title: "ðŸ§€ Coin Change II"
description: '[leetcode link](https://leetcode.com/problems/coin-change-ii/description/)'
mode: 'wide'
---
<Tabs>
  <Tab title="Question" icon="circle-question" iconType="regular">
    <Card>
      <p>You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.</p>  <p>Return <em>the number of combinations that make up that amount</em>. If that amount of money cannot be made up by any combination of the coins, return <code>0</code>.</p>  <p>You may assume that you have an infinite number of each kind of coin.</p>  <p>The answer is <strong>guaranteed</strong> to fit into a signed <strong>32-bit</strong> integer.</p>   <p><strong class="example">Example 1:</strong></p>   <strong>Input:</strong> amount = 5, coins = [1,2,5] <br/> <strong>Output:</strong> 4 <br/> <strong>Explanation:</strong> there are four ways to make up the amount: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1   <p><strong class="example">Example 2:</strong></p>   <strong>Input:</strong> amount = 3, coins = [2] <br/> <strong>Output:</strong> 0 <br/> <strong>Explanation:</strong> the amount of 3 cannot be made up just with coins of 2.   <p><strong class="example">Example 3:</strong></p>   <strong>Input:</strong> amount = 10, coins = [10] <br/> <strong>Output:</strong> 1    <p><strong>Constraints:</strong></p>  <ul>  <li><code>1 &lt;= coins.length &lt;= 300</code></li>  <li><code>1 &lt;= coins[i] &lt;= 5000</code></li>  <li>All the values of <code>coins</code> are <strong>unique</strong>.</li>  <li><code>0 &lt;= amount &lt;= 5000</code></li> </ul> 
    </Card>
  </Tab>
  <Tab title="Solution" icon="lightbulb" iconType="regular" >
    <Card>
      No notes for this problem
</Card>
  <Expandable title="code">
    <CodeGroup dropdown>
```ruby title="Coin Change II" lines
def recurse(amount, index)
  return 1 if amount == 0
  return 0 if amount < 0
  return 0 if index > @coins.size - 1

#   return @mem[amount][index] if @mem[amount][index]

  @mem[amount][index] ||= recurse(amount - @coins[index], index) + recurse(amount, index + 1)
end

def change(amount, coins)
  # amount cannot be made from coins that bigger that amount. so just filter all those coins out
  coins.select! { |coin| coin <= amount }
  @coins = coins.sort {|x,y| -(x <=> y)}
  @mem = Array.new(amount + 1) { Array.new(coins.size) }
  recurse(amount, 0)
end
```
    </CodeGroup>
  </Expandable>
  </Tab>
</Tabs>